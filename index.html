<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>Lens Ray Diagram Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #2d3436;
            overflow-x: hidden;
            /* Updated touch-action to allow zooming (manipulation) but prevents double-tap zoom delay */
            touch-action: manipulation; 
            -webkit-tap-highlight-color: transparent;
        }

        .container {
            width: 95%;
            max-width: 1200px;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
            animation: slideIn 0.5s ease-out;
            /* Ensure container doesn't overflow horizontally on small screens */
            overflow: hidden; 
        }

        .intro-screen, .game-screen, .results-screen {
            display: none;
        }

        .intro-screen.active, .game-screen.active, .results-screen.active {
            display: block;
        }

        .title {
            text-align: center;
            font-size: 2.8em;
            font-weight: 800;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 20px;
            letter-spacing: -1px;
        }

        .subtitle {
            text-align: center;
            font-size: 1.2em;
            color: #636e72;
            margin-bottom: 30px;
        }

        .instructions {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 20px;
            line-height: 1.8;
            border-left: 5px solid #667eea;
        }

        .instructions h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.4em;
        }

        .instructions ul {
            margin-left: 20px;
        }

        .instructions li {
            margin: 10px 0;
            color: #2d3436;
        }

        .ray-info {
            background: #fff3cd;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            border-left: 5px solid #ffc107;
        }

        .ray-info h4 {
            color: #856404;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .ray-info p {
            color: #856404;
            margin: 8px 0;
            line-height: 1.6;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.2em;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            min-height: 44px;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-center {
            display: block;
            margin: 0 auto;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .stats {
            display: flex;
            gap: 30px;
            align-items: center;
        }

        .stat {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.1em;
            font-weight: 600;
        }

        .stat-label {
            color: #636e72;
        }

        .stat-value {
            color: #667eea;
            font-size: 1.3em;
        }

        .timer {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
            color: white;
            padding: 10px 25px;
            border-radius: 50px;
            font-size: 1.3em;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
        }

        .timer.warning {
            animation: pulse 1s infinite;
        }

        .game-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn-small {
            padding: 8px 20px;
            font-size: 1em;
            background: #74b9ff;
            box-shadow: 0 2px 10px rgba(116, 185, 255, 0.4);
            min-height: 44px;
        }

        .btn-skip {
            background: linear-gradient(135deg, #ffa502 0%, #ff6348 100%);
            box-shadow: 0 2px 10px rgba(255, 165, 2, 0.4);
        }

        .btn-end {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
            box-shadow: 0 2px 10px rgba(255, 107, 107, 0.4);
        }

        .canvas-container {
            position: relative;
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            /* Allow scrolling within the canvas container if it's too big */
            overflow: auto; 
        }

        canvas {
            border: 2px solid #dfe6e9;
            border-radius: 10px;
            cursor: crosshair;
            display: block;
            margin: 0 auto;
            background: #fafbfc;
            max-width: 100%;
            /* Removed touch-action: none so zooming works, will handle events in JS */
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            align-items: center;
        }

        .btn-action {
            background: linear-gradient(135deg, #00b894 0%, #00cec9 100%);
            box-shadow: 0 4px 15px rgba(0, 184, 148, 0.4);
        }

        .btn-undo {
            background: linear-gradient(135deg, #fdcb6e 0%, #e17055 100%);
            box-shadow: 0 4px 15px rgba(253, 203, 110, 0.4);
        }

        .mode-indicator {
            background: #e3f2fd;
            padding: 10px 20px;
            border-radius: 50px;
            font-weight: 600;
            color: #1976d2;
            display: inline-block;
        }

        .attempts-remaining {
            background: #ff6b6b;
            color: white;
            padding: 8px 20px;
            border-radius: 50px;
            font-weight: 600;
            display: inline-block;
        }

        .feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            text-align: center;
            z-index: 1000;
            min-width: 300px;
            display: none;
        }

        .feedback.show {
            display: block;
            animation: slideIn 0.3s ease-out;
        }

        .feedback.correct {
            border: 5px solid #2ecc71;
        }

        .feedback.incorrect {
            border: 5px solid #e74c3c;
        }

        .feedback h2 {
            font-size: 2.5em;
            margin-bottom: 15px;
        }

        .feedback.correct h2 {
            color: #2ecc71;
        }

        .feedback.incorrect h2 {
            color: #e74c3c;
        }

        .feedback p {
            font-size: 1.2em;
            color: #636e72;
        }

        .results-summary {
            background: #f8f9fa;
            padding: 30px;
            border-radius: 15px;
            margin: 20px 0;
        }

        .results-summary h3 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.8em;
        }

        .result-stat {
            display: flex;
            justify-content: space-between;
            padding: 15px;
            margin: 10px 0;
            background: white;
            border-radius: 10px;
            border-left: 5px solid #667eea;
        }

        .result-stat-label {
            font-weight: 600;
            color: #2d3436;
        }

        .result-stat-value {
            font-size: 1.3em;
            color: #667eea;
            font-weight: 700;
        }

        .mistakes-list {
            background: #fff3cd;
            padding: 20px;
            border-radius: 15px;
            margin-top: 20px;
            border-left: 5px solid #ffc107;
        }

        .mistakes-list h4 {
            color: #856404;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .mistakes-list ul {
            margin-left: 20px;
        }

        .mistakes-list li {
            color: #856404;
            margin: 10px 0;
            line-height: 1.6;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
                width: 100%;
                border-radius: 10px;
            }

            .title {
                font-size: 1.8em;
            }

            .subtitle {
                font-size: 1em;
            }

            .game-header {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }

            .stats {
                flex-wrap: wrap;
                justify-content: space-around;
                gap: 15px;
            }

            .stat {
                font-size: 0.95em;
            }

            .stat-value {
                font-size: 1.2em;
            }

            .timer {
                text-align: center;
                font-size: 1.1em;
                padding: 8px 20px;
            }

            .game-controls {
                justify-content: center;
            }

            .btn-small {
                padding: 10px 18px;
                font-size: 0.95em;
            }

            canvas {
                width: 100% !important;
                height: auto !important;
                max-width: 100%;
            }

            .canvas-container {
                padding: 10px;
            }

            .instructions, .ray-info {
                padding: 15px;
                font-size: 0.95em;
            }

            .instructions ul, .ray-info p {
                font-size: 0.9em;
            }

            .btn {
                padding: 12px 30px;
                font-size: 1em;
            }

            .mode-indicator {
                font-size: 0.9em;
                padding: 8px 15px;
            }

            .attempts-remaining {
                font-size: 0.85em;
                padding: 6px 15px;
            }

            .action-buttons {
                gap: 10px;
            }

            .feedback {
                width: 90%;
                padding: 25px;
            }

            .feedback h2 {
                font-size: 2em;
            }

            .feedback p {
                font-size: 1em;
            }

            .results-summary {
                padding: 20px;
            }

            .result-stat {
                flex-direction: column;
                gap: 5px;
                padding: 12px;
            }

            .result-stat-value {
                font-size: 1.5em;
            }

            .mistakes-list {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="intro-screen active">
            <h1 class="title">ðŸ”¬ Lens Ray Diagram Game</h1>
            <p class="subtitle">Master the art of drawing ray diagrams!</p>
            
            <div class="instructions">
                <h3>ðŸ“‹ How to Play</h3>
                <ul>
                    <li><strong>Goal:</strong> Complete as many ray diagrams as possible in 5 minutes!</li>
                    <li><strong>Drawing Rays:</strong> Click twice to draw a ray - once at the start, once at the end. Rays snap to the grid.</li>
                    <li><strong>Placing the Image:</strong> After drawing 2+ rays, click "Place Image" and mark the base and top of the image.</li>
                    <li><strong>Scoring:</strong> Get points for correct diagrams. Higher accuracy = bonus points!</li>
                    <li><strong>Attempts:</strong> You get 3 attempts per question. Wrong rays can be deleted.</li>
                    <li><strong>Controls:</strong> Use Undo, Skip, or End Early buttons as needed.</li>
                </ul>
            </div>

            <div class="ray-info">
                <h4>ðŸŒŸ Principal Rays for Convex Lenses:</h4>
                <p><strong>Ray 1:</strong> Parallel to axis â†’ passes through far focal point</p>
                <p><strong>Ray 2:</strong> Through center â†’ continues straight</p>
                <p><strong>Ray 3:</strong> From near focal point â†’ emerges parallel</p>
                
                <h4 style="margin-top: 15px;">ðŸŒŸ Principal Rays for Concave Lenses:</h4>
                <p><strong>Ray 1:</strong> Parallel to axis â†’ diverges (appears to come from near focal point)</p>
                <p><strong>Ray 2:</strong> Through center â†’ continues straight</p>
                <p><strong>Ray 3:</strong> From near focal point to lens â†’ straight line continuation</p>
            </div>

            <button class="btn btn-center" onclick="startGame()">Start Game! ðŸš€</button>
        </div>

        <div class="game-screen">
            <div class="game-header">
                <div class="stats">
                    <div class="stat">
                        <span class="stat-label">Score:</span>
                        <span class="stat-value" id="score">0</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Correct:</span>
                        <span class="stat-value" id="correct">0</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Question:</span>
                        <span class="stat-value" id="questionNum">1</span>
                    </div>
                </div>
                <div class="timer" id="timer">5:00</div>
                <div class="game-controls">
                    <button class="btn btn-small btn-end" onclick="endGame()">End Early</button>
                    <button class="btn btn-small btn-skip" onclick="skipQuestion()">Skip</button>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="gameCanvas"></canvas>
            </div>

            <div class="action-buttons">
                <div class="mode-indicator" id="modeIndicator">Drawing Rays</div>
                <span class="attempts-remaining" id="attemptsIndicator" style="display: none;">Attempts: 3</span>
                <button class="btn btn-small btn-undo" onclick="undoLastRay()" id="undoBtn">â†¶ Undo Ray</button>
                <button class="btn btn-action" onclick="startPlacingImage()" id="placeImageBtn" style="display: none;">Place Image âœ“</button>
                <button class="btn btn-small btn-skip" onclick="cancelPlacingImage()" id="cancelImageBtn" style="display: none;">âœ— Cancel</button>
            </div>
        </div>

        <div class="results-screen">
            <h1 class="title">ðŸŽ¯ Game Complete!</h1>
            <p class="subtitle">Here's how you did:</p>

            <div class="results-summary">
                <h3>ðŸ“Š Your Statistics</h3>
                <div class="result-stat">
                    <span class="result-stat-label">Total Score</span>
                    <span class="result-stat-value" id="finalScore">0</span>
                </div>
                <div class="result-stat">
                    <span class="result-stat-label">Questions Attempted</span>
                    <span class="result-stat-value" id="finalAttempted">0</span>
                </div>
                <div class="result-stat">
                    <span class="result-stat-label">Correct Answers</span>
                    <span class="result-stat-value" id="finalCorrect">0</span>
                </div>
                <div class="result-stat">
                    <span class="result-stat-label">Accuracy</span>
                    <span class="result-stat-value" id="finalAccuracy">0%</span>
                </div>
            </div>

            <div class="mistakes-list" id="mistakesList">
                <h4>ðŸ’¡ Common Mistakes</h4>
                <ul id="mistakesUl">
                    <li>No mistakes recorded - great job!</li>
                </ul>
            </div>

            <button class="btn btn-center" onclick="location.reload()">Play Again! ðŸ”„</button>
        </div>

        <div class="feedback" id="feedback">
            <h2 id="feedbackTitle">Correct!</h2>
            <p id="feedbackText">Great job!</p>
        </div>
    </div>

    <script>
        let canvas, ctx, GRID_SIZE = 20;
        let gameState;
        
        document.addEventListener('DOMContentLoaded', function() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            gameState = {
                timeRemaining: 300, // 5 minutes in seconds
                score: 0,
                correctCount: 0,
                questionCount: 0,
                attemptedCount: 0,
                currentQuestion: null,
                rays: [],
                imagePoints: [],
                mode: 'drawingRays', // 'drawingRays' or 'placingImage'
                attemptsRemaining: 3,
                mistakes: [],
                timerInterval: null
            };
            
            window.addEventListener('resize', resizeCanvas);
            window.addEventListener('load', resizeCanvas);
            
            // Add canvas event listeners
            canvas.addEventListener('click', handleCanvasInteraction);
            canvas.addEventListener('touchend', handleCanvasInteraction);
            
            // Note: removed e.preventDefault() for touchstart/move to allow zooming if needed,
            // but we handle touch logic in handleCanvasInteraction
        });
        
        // Responsive canvas setup
        function resizeCanvas() {
            const container = canvas.parentElement;
            const containerWidth = container.clientWidth - 40; // Account for padding
            
            if (window.innerWidth <= 768) {
                // Mobile
                canvas.width = Math.min(containerWidth, 800);
                canvas.height = Math.min(canvas.width * 0.75, 600);
                GRID_SIZE = Math.max(canvas.width / 30, 20); 
            } else {
                // Desktop
                canvas.width = 1000;
                canvas.height = 600;
                GRID_SIZE = 20;
            }
            
            if (gameState && gameState.currentQuestion) {
                drawScene();
            }
        }

        function startGame() {
            document.querySelector('.intro-screen').classList.remove('active');
            document.querySelector('.game-screen').classList.add('active');
            
            resizeCanvas();
            gameState.timerInterval = setInterval(updateTimer, 1000);
            generateQuestion();
        }

        function updateTimer() {
            gameState.timeRemaining--;
            
            const minutes = Math.floor(gameState.timeRemaining / 60);
            const seconds = gameState.timeRemaining % 60;
            const timerEl = document.getElementById('timer');
            timerEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            if (gameState.timeRemaining <= 30) {
                timerEl.classList.add('warning');
            }
            
            if (gameState.timeRemaining <= 0) {
                endGame();
            }
        }

        function generateQuestion() {
            gameState.questionCount++;
            gameState.attemptedCount++;
            gameState.rays = [];
            gameState.imagePoints = [];
            gameState.mode = 'drawingRays';
            gameState.attemptsRemaining = 3;
            
            document.getElementById('questionNum').textContent = gameState.questionCount;
            document.getElementById('placeImageBtn').style.display = 'none';
            document.getElementById('cancelImageBtn').style.display = 'none';
            document.getElementById('modeIndicator').textContent = 'Drawing Rays';
            document.getElementById('attemptsIndicator').style.display = 'none';
            
            const lensType = Math.random() < 0.5 ? 'convex' : 'concave';
            
            // Focal length scaled to canvas size
            const maxFocalLength = Math.min((canvas.width / 2) * 0.4, 150);
            const minFocalLength = Math.max(GRID_SIZE * 2, 50);
            
            let focalLength = minFocalLength + Math.floor(Math.random() * (maxFocalLength - minFocalLength));
            focalLength = Math.round(focalLength / GRID_SIZE) * GRID_SIZE; // Snap to grid
            
            let objectDistance, objectHeight;
            
            const maxObjectDistance = (canvas.width / 2) * 0.5;
            
            if (lensType === 'convex') {
                // Avoid object at focal point
                if (Math.random() < 0.3) {
                    // Object inside focal length
                    objectDistance = GRID_SIZE * 2 + Math.floor(Math.random() * (focalLength - GRID_SIZE * 4));
                } else {
                    // Object outside focal length
                    objectDistance = focalLength + GRID_SIZE * 2 + Math.floor(Math.random() * Math.min(100, maxObjectDistance - focalLength));
                }
            } else {
                // Concave lens - any position works
                objectDistance = GRID_SIZE * 3 + Math.floor(Math.random() * Math.min(150, maxObjectDistance));
            }
            
            // Snap to grid
            objectDistance = Math.round(objectDistance / GRID_SIZE) * GRID_SIZE;
            
            // Object height scaled to canvas
            const maxInitialHeight = Math.min((canvas.height / 2) * 0.3, 60);
            const minInitialHeight = GRID_SIZE * 2;
            
            objectHeight = minInitialHeight + Math.floor(Math.random() * (maxInitialHeight - minInitialHeight));
            objectHeight = Math.round(objectHeight / GRID_SIZE) * GRID_SIZE;
            
            // Ensure object height fits on screen
            const maxObjectHeight = (canvas.height / 2) - GRID_SIZE * 5;
            if (objectHeight > maxObjectHeight) {
                objectHeight = Math.round(maxObjectHeight / GRID_SIZE) * GRID_SIZE;
            }
            
            // For convex lenses, check that the image will be on screen
            if (lensType === 'convex') {
                const u = objectDistance;
                const f = focalLength;
                
                // Maximum safe distance for image to stay on screen
                const maxImageDistance = (canvas.width / 2) - GRID_SIZE * 3;
                
                if (Math.abs(u - f) > 5) { // Not at focal point
                    const v = (f * u) / (u - f);
                    const m = v / u;
                    const imageHeight = Math.abs(m * objectHeight);
                    
                    if (u > f) {
                        const imageDistance = Math.abs(v);
                        if (imageDistance > maxImageDistance || imageHeight > (canvas.height / 2) - GRID_SIZE * 3) {
                            objectDistance = f + Math.min(focalLength * 0.8, 60);
                            objectDistance = Math.round(objectDistance / GRID_SIZE) * GRID_SIZE;
                        }
                    } else {
                        const imageDistance = Math.abs(v);
                        if (imageDistance > maxImageDistance || imageHeight > (canvas.height / 2) - GRID_SIZE * 3) {
                            objectDistance = Math.max(focalLength * 0.3, GRID_SIZE * 2);
                            objectDistance = Math.round(objectDistance / GRID_SIZE) * GRID_SIZE;
                        }
                    }
                }
            } else {
                // For concave lenses
                const u = objectDistance;
                const f = focalLength;
                const v = (f * u) / (u + f);
                const m = v / u;
                const imageHeight = Math.abs(m * objectHeight);
                const imageDistance = Math.abs(v);
                
                const maxImageDistance = (canvas.width / 2) - GRID_SIZE * 3;
                
                if (imageDistance > maxImageDistance || imageHeight > (canvas.height / 2) - GRID_SIZE * 3) {
                    objectDistance = Math.min(focalLength * 1.5, 80);
                    objectDistance = Math.round(objectDistance / GRID_SIZE) * GRID_SIZE;
                }
            }
            
            gameState.currentQuestion = {
                lensType,
                focalLength,
                objectDistance,
                objectHeight,
                lensX: canvas.width / 2,
                lensY: canvas.height / 2
            };
            
            drawScene();
        }

        function drawScene() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = window.innerWidth <= 768 ? 1.5 : 1;
            for (let x = 0; x <= canvas.width; x += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            const q = gameState.currentQuestion;
            
            // Draw principal axis (dashed)
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 5]);
            ctx.beginPath();
            ctx.moveTo(0, q.lensY);
            ctx.lineTo(canvas.width, q.lensY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw lens
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 4;
            const lensHeight = Math.min(canvas.height * 0.5, 150);
            
            ctx.beginPath();
            ctx.moveTo(q.lensX, q.lensY - lensHeight);
            ctx.lineTo(q.lensX, q.lensY + lensHeight);
            ctx.stroke();
            
            // Draw lens arrows
            const arrowSize = Math.max(20, GRID_SIZE * 1.2);
            ctx.fillStyle = '#000';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            
            if (q.lensType === 'convex') {
                drawLensArrowhead(ctx, q.lensX, q.lensY - lensHeight, 'up', arrowSize);
                drawLensArrowhead(ctx, q.lensX, q.lensY + lensHeight, 'down', arrowSize);
            } else {
                drawLensArrowhead(ctx, q.lensX, q.lensY - lensHeight, 'down', arrowSize);
                drawLensArrowhead(ctx, q.lensX, q.lensY + lensHeight, 'up', arrowSize);
            }
            
            // Draw focal points
            const focalPointLeft = q.lensX - q.focalLength;
            const focalPointRight = q.lensX + q.focalLength;
            const focalPointSize = Math.max(4, GRID_SIZE * 0.3);
            
            ctx.fillStyle = '#ff6b6b';
            ctx.beginPath();
            ctx.arc(focalPointLeft, q.lensY, focalPointSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(focalPointRight, q.lensY, focalPointSize, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#000';
            const fontSize = Math.max(12, GRID_SIZE * 0.7);
            ctx.font = `bold ${fontSize}px sans-serif`;
            ctx.fillText('F', focalPointLeft - 5, q.lensY - 10);
            ctx.fillText('F', focalPointRight - 5, q.lensY - 10);
            
            // Draw object
            const objX = q.lensX - q.objectDistance;
            const objY = q.lensY;
            const objHeight = q.objectHeight;
            drawObjectImageArrow(ctx, objX, objY, objX, objY - objHeight, 10, '#2196f3', 3);
            
            ctx.fillStyle = '#2196f3';
            ctx.font = `bold ${fontSize}px sans-serif`;
            ctx.fillText('O', objX - 15, objY + 20);
            
            // Draw rays
            gameState.rays.forEach((ray, index) => {
                const colors = ['#e74c3c', '#2ecc71', '#f39c12'];
                const rayColor = colors[index % 3];
                
                const passesThroughCenter = checkIfRayThroughCenter(ray, q);
                const passesThroughNearFocal = checkIfRayThroughNearFocalPoint(ray, q);
                const isParallel = checkIfParallelRay(ray, q);
                const isExitRay = (Math.abs(ray.x1 - q.lensX) < GRID_SIZE && ray.x2 > ray.x1);
                
                // --- CUSTOM BEHAVIOR FOR CONCAVE FOCAL RAYS (DASHED -> STRAIGHT) ---
                if (passesThroughNearFocal && passesThroughNearFocal.type === 'nearFocal') {
                    // Draw the F-to-lens portion as dashed
                    ctx.strokeStyle = rayColor;
                    ctx.lineWidth = 2.5;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(ray.x1, ray.y1);
                    ctx.lineTo(ray.x2, ray.y2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                } 
                else if (passesThroughNearFocal && passesThroughNearFocal.type === 'convexInsideFocalNearPoint') {
                    // Convex inside focal case (skip standard draw)
                } 
                // --- GENERAL RAY DRAWING ---
                else {
                    drawRayArrow(ctx, ray.x1, ray.y1, ray.x2, ray.y2, 8, rayColor, 2.5);
                }

                // --- EXTRAPOLATION AND EXTENSION LOGIC ---

                // 1. EXTEND EXIT RAYS (Fix for short Green Ray)
                // If a ray starts at the lens and goes right, automatically extend it to canvas edge
                if (isExitRay) {
                     // Calculate slope
                     const dx = ray.x2 - ray.x1;
                     const dy = ray.y2 - ray.y1;
                     if (dx !== 0) {
                        const m = dy / dx;
                        const finalX = canvas.width;
                        const finalY = ray.y1 + m * (finalX - ray.x1);
                        
                        // Draw extension over the user's short line
                        ctx.strokeStyle = rayColor;
                        ctx.lineWidth = 2.5;
                        ctx.beginPath();
                        ctx.moveTo(ray.x1, ray.y1); // Start exactly at lens
                        ctx.lineTo(finalX, finalY);
                        ctx.stroke();
                     }
                }
                
                const rayNeedsExtrapolation = shouldExtrapolateRay(ray, q) || passesThroughCenter || passesThroughNearFocal;
                
                if (rayNeedsExtrapolation) {
                    const dx = ray.x2 - ray.x1;
                    const dy = ray.y2 - ray.y1;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const dirX = dx / length;
                    const dirY = dy / length;
                    
                    let extrapX, extrapY;
                    
                    if (rayNeedsExtrapolation.type === 'convexInsideFocalNearPoint') {
                         // ... (existing convex logic) ...
                        const focalX = rayNeedsExtrapolation.focalX;
                        const focalY = rayNeedsExtrapolation.focalY;
                        const objectX = rayNeedsExtrapolation.objectX;
                        const objectTopY = rayNeedsExtrapolation.objectTopY;
                        
                        ctx.strokeStyle = rayColor;
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.moveTo(focalX, focalY);
                        ctx.lineTo(objectX, objectTopY);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        const dx2 = objectX - focalX;
                        const dy2 = objectTopY - focalY;
                        const t = (q.lensX - objectX) / dx2;
                        const yAtLens = objectTopY + t * dy2;
                        
                        drawRayArrow(ctx, objectX, objectTopY, q.lensX, yAtLens, 8, rayColor, 2.5);
                        
                        ctx.strokeStyle = rayColor;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(q.lensX, yAtLens);
                        ctx.lineTo(canvas.width, yAtLens);
                        ctx.stroke();
                        
                    } else if (rayNeedsExtrapolation.type === 'nearFocal') {
                        // --- MODIFIED CONCAVE BEHAVIOR ---
                        // "Dashed (virtual) and then extrapolate and become a real ray... continued along the same trajectory"
                        const yAtLens = rayNeedsExtrapolation.yAtLens;
                        
                        // Calculate incoming slope (from F to Lens)
                        const slopeY = (ray.y2 - ray.y1);
                        const slopeX = (ray.x2 - ray.x1);
                        const m = slopeY / slopeX;
                        
                        // Extend straight (same trajectory)
                        extrapX = canvas.width;
                        extrapY = yAtLens + m * (extrapX - q.lensX);
                        
                        ctx.strokeStyle = rayColor;
                        ctx.lineWidth = 2.5;
                        ctx.beginPath();
                        ctx.moveTo(q.lensX, yAtLens);
                        ctx.lineTo(extrapX, extrapY);
                        ctx.stroke();
                        
                    } else if (rayNeedsExtrapolation.type === 'center') {
                        // Center ray continues straight
                        const extrapLength = 500;
                        extrapX = ray.x2 + dirX * extrapLength;
                        extrapY = ray.y2 + dirY * extrapLength;
                        
                        ctx.strokeStyle = rayColor;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(ray.x2, ray.y2);
                        ctx.lineTo(extrapX, extrapY);
                        ctx.stroke();
                    } else if (rayNeedsExtrapolation.type === 'virtual') {
                        // Standard virtual extrapolation (backwards)
                        const extrapLength = 500;
                        extrapX = ray.x1 - dirX * extrapLength;
                        extrapY = ray.y1 - dirY * extrapLength;
                        
                        ctx.strokeStyle = rayColor;
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.moveTo(ray.x1, ray.y1);
                        ctx.lineTo(extrapX, extrapY);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                }
                
                // For concave lens, parallel rays
                if (q.lensType === 'concave' && isParallel && ray.x2 >= q.lensX) {
                    // --- REMOVED VIRTUAL BACK-TRACE FOR PARALLEL RAYS (Per Request) ---
                    // The dotted line drawing logic here has been removed.
                }
                
                // For convex lens with object inside focal length
                if (q.lensType === 'convex' && q.objectDistance < q.focalLength && isParallel && ray.x2 > q.lensX) {
                    const farFocalX = q.lensX + q.focalLength;
                    ctx.strokeStyle = rayColor;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(ray.x1, ray.y1);
                    ctx.lineTo(0, ray.y1);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            });
            
            // Draw image points if in placing mode
            if (gameState.mode === 'placingImage' && gameState.imagePoints.length > 0) {
                gameState.imagePoints.forEach(point => {
                    ctx.fillStyle = '#9b59b6';
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                if (gameState.imagePoints.length === 2) {
                    let basePoint, topPoint;
                    if (Math.abs(gameState.imagePoints[0].y - q.lensY) < Math.abs(gameState.imagePoints[1].y - q.lensY)) {
                        basePoint = gameState.imagePoints[0];
                        topPoint = gameState.imagePoints[1];
                    } else {
                        basePoint = gameState.imagePoints[1];
                        topPoint = gameState.imagePoints[0];
                    }
                    drawObjectImageArrow(ctx, basePoint.x, basePoint.y, topPoint.x, topPoint.y, 10, '#9b59b6', 3);
                }
            }
        }

        function checkIfRayThroughCenter(ray, q) {
            const tolerance = GRID_SIZE * 2;
            if (Math.abs(ray.x1 - q.lensX) < tolerance || Math.abs(ray.x2 - q.lensX) < tolerance) {
                const t = (q.lensX - ray.x1) / (ray.x2 - ray.x1);
                const yAtLens = ray.y1 + t * (ray.y2 - ray.y1);
                if (Math.abs(yAtLens - q.lensY) < tolerance) {
                    return { type: 'center' };
                }
            }
            return null;
        }

        function checkIfRayThroughNearFocalPoint(ray, q) {
            const tolerance = GRID_SIZE * 2;
            
            if (q.lensType === 'concave') {
                const nearFocalX = q.lensX - q.focalLength;
                const nearFocalY = q.lensY;
                
                if (ray.x1 !== ray.x2) {
                    const startsAtFocal = Math.abs(ray.x1 - nearFocalX) < tolerance && 
                                         Math.abs(ray.y1 - nearFocalY) < tolerance;
                    const endsAtLens = Math.abs(ray.x2 - q.lensX) < tolerance;
                    
                    if (startsAtFocal && endsAtLens) {
                        return { 
                            type: 'nearFocal',
                            focalX: nearFocalX,
                            focalY: nearFocalY,
                            yAtLens: ray.y2
                        };
                    }
                }
            }
            
            if (q.lensType === 'convex' && q.objectDistance < q.focalLength) {
                const nearFocalX = q.lensX - q.focalLength;
                const nearFocalY = q.lensY;
                const objectX = q.lensX - q.objectDistance;
                const objectTopY = q.lensY - q.objectHeight;
                
                if (ray.x1 !== ray.x2) {
                    const startsAtFocal = Math.abs(ray.x1 - nearFocalX) < tolerance && 
                                         Math.abs(ray.y1 - nearFocalY) < tolerance;
                    const goesTowardObject = ray.x2 < ray.x1 && ray.x2 > objectX - tolerance;
                    
                    if (startsAtFocal && goesTowardObject) {
                        return {
                            type: 'convexInsideFocalNearPoint',
                            focalX: nearFocalX,
                            focalY: nearFocalY,
                            objectX: objectX,
                            objectTopY: objectTopY
                        };
                    }
                }
            }
            
            return null;
        }

        function checkIfParallelRay(ray, q) {
            const tolerance = GRID_SIZE * 1;
            if (Math.abs(ray.y2 - ray.y1) < tolerance) {
                return { type: 'parallel', yLevel: ray.y1 };
            }
            return null;
        }

        function shouldExtrapolateRay(ray, q) {
            const tolerance = GRID_SIZE * 2;
            if (q.lensType === 'concave') {
                if (ray.x2 > q.lensX - tolerance) {
                    return { type: 'virtual' };
                }
            } else {
                if (q.objectDistance < q.focalLength) {
                    if (ray.x2 > q.lensX - tolerance) {
                        return { type: 'virtual' };
                    }
                }
            }
            return null;
        }

        function drawLensArrowhead(ctx, x, y, direction, size) {
            ctx.fillStyle = '#000';
            ctx.beginPath();
            if (direction === 'up') {
                ctx.moveTo(x, y - size);
                ctx.lineTo(x - size/2, y);
                ctx.lineTo(x + size/2, y);
            } else if (direction === 'down') {
                ctx.moveTo(x, y + size);
                ctx.lineTo(x - size/2, y);
                ctx.lineTo(x + size/2, y);
            }
            ctx.closePath();
            ctx.fill();
        }

        function drawObjectImageArrow(ctx, x1, y1, x2, y2, arrowSize, color, lineWidth = 2) {
            const responsiveArrowSize = Math.max(arrowSize, GRID_SIZE * 0.5);
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            const angle = Math.atan2(y2 - y1, x2 - x1);
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - responsiveArrowSize * Math.cos(angle - Math.PI / 6), 
                       y2 - responsiveArrowSize * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(x2 - responsiveArrowSize * Math.cos(angle + Math.PI / 6), 
                       y2 - responsiveArrowSize * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
        }

        function drawRayArrow(ctx, x1, y1, x2, y2, arrowSize, color, lineWidth = 2) {
            const responsiveArrowSize = Math.max(arrowSize, GRID_SIZE * 0.4);
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            const midX = (x1 + x2) / 2;
            const midY = (y1 + y2) / 2;
            const angle = Math.atan2(y2 - y1, x2 - x1);
            ctx.beginPath();
            ctx.moveTo(midX, midY);
            ctx.lineTo(midX - responsiveArrowSize * Math.cos(angle - Math.PI / 6), 
                       midY - responsiveArrowSize * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(midX - responsiveArrowSize * Math.cos(angle + Math.PI / 6), 
                       midY - responsiveArrowSize * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
        }

        function snapToGrid(x, y) {
            return {
                x: Math.round(x / GRID_SIZE) * GRID_SIZE,
                y: Math.round(y / GRID_SIZE) * GRID_SIZE
            };
        }

        let clickCount = 0;
        let firstClick = null;

        function handleCanvasInteraction(e) {
            // Only prevent default if it's not a pinch zoom gesture (requires >1 touch)
            if (e.type === 'touchmove' && e.touches.length > 1) return;
            
            // Allow default zoom, but we need to handle coordinates properly
            if (e.type === 'click' || e.type === 'touchend') {
                const rect = canvas.getBoundingClientRect();
                let x, y;
                
                if (e.type === 'touchend') {
                    // For touchend, we use changedTouches
                    const touch = e.changedTouches[0];
                    x = touch.clientX - rect.left;
                    y = touch.clientY - rect.top;
                    
                    // Basic debounce for touch vs click
                    e.preventDefault();
                } else {
                    x = e.clientX - rect.left;
                    y = e.clientY - rect.top;
                }
                
                // Scale coordinates
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                x *= scaleX;
                y *= scaleY;
                
                const snapped = snapToGrid(x, y);
                
                if (gameState.mode === 'drawingRays') {
                    if (clickCount === 0) {
                        firstClick = snapped;
                        clickCount = 1;
                        ctx.fillStyle = 'rgba(102, 126, 234, 0.5)';
                        ctx.beginPath();
                        ctx.arc(snapped.x, snapped.y, 10, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        gameState.rays.push({
                            x1: firstClick.x,
                            y1: firstClick.y,
                            x2: snapped.x,
                            y2: snapped.y
                        });
                        clickCount = 0;
                        firstClick = null;
                        
                        if (gameState.rays.length >= 2) {
                            document.getElementById('placeImageBtn').style.display = 'inline-block';
                        }
                        drawScene();
                    }
                } else if (gameState.mode === 'placingImage') {
                    gameState.imagePoints.push(snapped);
                    if (gameState.imagePoints.length === 2) {
                        checkAnswer();
                    }
                    drawScene();
                }
            }
        }

        function undoLastRay() {
            if (gameState.rays.length > 0) {
                gameState.rays.pop();
                if (gameState.rays.length < 2) {
                    document.getElementById('placeImageBtn').style.display = 'none';
                }
                drawScene();
            }
            clickCount = 0;
            firstClick = null;
            drawScene();
        }

        function startPlacingImage() {
            gameState.mode = 'placingImage';
            gameState.imagePoints = [];
            document.getElementById('modeIndicator').textContent = 'Placing Image (click base, then top)';
            document.getElementById('placeImageBtn').style.display = 'none';
            document.getElementById('cancelImageBtn').style.display = 'inline-block';
        }
        
        function cancelPlacingImage() {
            gameState.mode = 'drawingRays';
            gameState.imagePoints = [];
            document.getElementById('modeIndicator').textContent = 'Drawing Rays';
            document.getElementById('cancelImageBtn').style.display = 'none';
            if (gameState.rays.length >= 2) {
                document.getElementById('placeImageBtn').style.display = 'inline-block';
            }
            drawScene();
        }

        function calculateImagePosition() {
            const q = gameState.currentQuestion;
            const u = q.objectDistance;
            const f = q.focalLength;
            let v, m, imageHeight;
            
            if (q.lensType === 'convex') {
                if (Math.abs(u - f) < 5) return null;
                v = (f * u) / (u - f);
                m = v / u;
                imageHeight = m * q.objectHeight;
                return {
                    distance: Math.abs(v),
                    height: Math.abs(imageHeight),
                    isReal: v > 0,
                    isInverted: v > 0,
                    side: v > 0 ? 'right' : 'left'
                };
            } else {
                v = (f * u) / (u + f);
                m = v / u;
                imageHeight = m * q.objectHeight;
                return {
                    distance: Math.abs(v),
                    height: Math.abs(imageHeight),
                    isReal: false,
                    isInverted: false,
                    side: 'left'
                };
            }
        }

        function checkAnswer() {
            const q = gameState.currentQuestion;
            const correctImage = calculateImagePosition();
            
            if (!correctImage) {
                showFeedback(false, "No real image is formed when object is at the focal point!");
                return;
            }
            
            let expectedImageX;
            if (correctImage.side === 'right') {
                expectedImageX = q.lensX + correctImage.distance;
            } else {
                expectedImageX = q.lensX - correctImage.distance;
            }
            expectedImageX = Math.round(expectedImageX / GRID_SIZE) * GRID_SIZE;
            
            const expectedImageY1 = q.lensY;
            let expectedImageY2 = correctImage.isInverted ? 
                q.lensY + correctImage.height : 
                q.lensY - correctImage.height;
            expectedImageY2 = Math.round(expectedImageY2 / GRID_SIZE) * GRID_SIZE;
            
            const userPoints = gameState.imagePoints;
            let basePoint, topPoint;
            if (Math.abs(userPoints[0].y - q.lensY) < Math.abs(userPoints[1].y - q.lensY)) {
                basePoint = userPoints[0];
                topPoint = userPoints[1];
            } else {
                basePoint = userPoints[1];
                topPoint = userPoints[0];
            }
            
            const tolerance = 20;
            const xCorrect = Math.abs(basePoint.x - expectedImageX) < tolerance;
            const baseYCorrect = Math.abs(basePoint.y - expectedImageY1) < tolerance;
            const topYCorrect = Math.abs(topPoint.y - expectedImageY2) < tolerance;
            const topXCorrect = Math.abs(topPoint.x - expectedImageX) < tolerance;
            
            const imageCorrect = xCorrect && baseYCorrect && topYCorrect && topXCorrect;
            const raysCorrect = gameState.rays.length >= 2;
            
            if (imageCorrect && raysCorrect) {
                const basePoints = 100;
                const accuracyBonus = gameState.attemptsRemaining === 3 ? 50 : 
                                     gameState.attemptsRemaining === 2 ? 25 : 0;
                const totalPoints = basePoints + accuracyBonus;
                
                gameState.score += totalPoints;
                gameState.correctCount++;
                
                document.getElementById('score').textContent = gameState.score;
                document.getElementById('correct').textContent = gameState.correctCount;
                
                showFeedback(true, `+${totalPoints} points!`);
                setTimeout(() => {
                    generateQuestion();
                }, 2000);
            } else {
                gameState.attemptsRemaining--;
                let errorMsg = 'Not quite right. ';
                if (!imageCorrect) {
                    errorMsg += `Image position is off. `;
                    gameState.mistakes.push('Image position incorrect');
                }
                
                if (gameState.attemptsRemaining > 0) {
                    errorMsg += `${gameState.attemptsRemaining} attempts remaining.`;
                    showFeedback(false, errorMsg);
                    gameState.mode = 'drawingRays';
                    gameState.imagePoints = [];
                    document.getElementById('modeIndicator').textContent = 'Drawing Rays - Try Again';
                    document.getElementById('attemptsIndicator').style.display = 'inline-block';
                    document.getElementById('attemptsIndicator').textContent = `Attempts: ${gameState.attemptsRemaining}`;
                    drawScene();
                } else {
                    showFeedback(false, "Out of attempts. Moving to next question.");
                    setTimeout(() => {
                        generateQuestion();
                    }, 2000);
                }
            }
        }

        function showFeedback(isCorrect, message) {
            const feedback = document.getElementById('feedback');
            const title = document.getElementById('feedbackTitle');
            const text = document.getElementById('feedbackText');
            
            feedback.className = 'feedback show ' + (isCorrect ? 'correct' : 'incorrect');
            title.textContent = isCorrect ? 'âœ“ Correct!' : 'âœ— Incorrect';
            text.textContent = message;
            
            setTimeout(() => {
                feedback.classList.remove('show');
            }, isCorrect ? 2000 : 3000);
        }

        function skipQuestion() {
            gameState.mistakes.push('Question skipped');
            generateQuestion();
        }

        function endGame() {
            clearInterval(gameState.timerInterval);
            document.querySelector('.game-screen').classList.remove('active');
            document.querySelector('.results-screen').classList.add('active');
            const accuracy = gameState.attemptedCount > 0 ? 
                Math.round((gameState.correctCount / gameState.attemptedCount) * 100) : 0;
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('finalAttempted').textContent = gameState.attemptedCount;
            document.getElementById('finalCorrect').textContent = gameState.correctCount;
            document.getElementById('finalAccuracy').textContent = accuracy + '%';
            const mistakesUl = document.getElementById('mistakesUl');
            if (gameState.mistakes.length > 0) {
                const mistakeCounts = {};
                gameState.mistakes.forEach(m => {
                    mistakeCounts[m] = (mistakeCounts[m] || 0) + 1;
                });
                mistakesUl.innerHTML = '';
                Object.entries(mistakeCounts).forEach(([mistake, count]) => {
                    const li = document.createElement('li');
                    li.textContent = `${mistake} (${count} time${count > 1 ? 's' : ''})`;
                    mistakesUl.appendChild(li);
                });
            } else {
                mistakesUl.innerHTML = '<li>No mistakes recorded - perfect performance!</li>';
            }
        }
    </script>
</body>
</html>
