<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Lens Ray Diagram Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes correctFlash {
            0%, 100% { background: rgba(46, 213, 115, 0.2); }
            50% { background: rgba(46, 213, 115, 0.4); }
        }

        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #2d3436;
            overflow-x: hidden;
            touch-action: pan-y; /* Allow vertical scrolling but prevent pinch zoom */
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight on mobile */
        }

        .container {
            width: 95%;
            max-width: 1200px;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
            animation: slideIn 0.5s ease-out;
        }

        .intro-screen, .game-screen, .results-screen {
            display: none;
        }

        .intro-screen.active, .game-screen.active, .results-screen.active {
            display: block;
        }

        .title {
            text-align: center;
            font-size: 2.8em;
            font-weight: 800;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 20px;
            letter-spacing: -1px;
        }

        .subtitle {
            text-align: center;
            font-size: 1.2em;
            color: #636e72;
            margin-bottom: 30px;
        }

        .instructions {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 20px;
            line-height: 1.8;
            border-left: 5px solid #667eea;
        }

        .instructions h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.4em;
        }

        .instructions ul {
            margin-left: 20px;
        }

        .instructions li {
            margin: 10px 0;
            color: #2d3436;
        }

        .ray-info {
            background: #fff3cd;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            border-left: 5px solid #ffc107;
        }

        .ray-info h4 {
            color: #856404;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .ray-info p {
            color: #856404;
            margin: 8px 0;
            line-height: 1.6;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.2em;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            min-height: 44px; /* Minimum touch target size for mobile */
            -webkit-tap-highlight-color: transparent;
            user-select: none; /* Prevent text selection on touch */
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-center {
            display: block;
            margin: 0 auto;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .stats {
            display: flex;
            gap: 30px;
            align-items: center;
        }

        .stat {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.1em;
            font-weight: 600;
        }

        .stat-label {
            color: #636e72;
        }

        .stat-value {
            color: #667eea;
            font-size: 1.3em;
        }

        .timer {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
            color: white;
            padding: 10px 25px;
            border-radius: 50px;
            font-size: 1.3em;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
        }

        .timer.warning {
            animation: pulse 1s infinite;
        }

        .game-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn-small {
            padding: 8px 20px;
            font-size: 1em;
            background: #74b9ff;
            box-shadow: 0 2px 10px rgba(116, 185, 255, 0.4);
            min-height: 44px; /* Minimum touch target */
        }

        .btn-skip {
            background: linear-gradient(135deg, #ffa502 0%, #ff6348 100%);
            box-shadow: 0 2px 10px rgba(255, 165, 2, 0.4);
        }

        .btn-end {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
            box-shadow: 0 2px 10px rgba(255, 107, 107, 0.4);
        }

        .canvas-container {
            position: relative;
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        canvas {
            border: 2px solid #dfe6e9;
            border-radius: 10px;
            cursor: crosshair;
            display: block;
            margin: 0 auto;
            background: #fafbfc;
            max-width: 100%;
            touch-action: none; /* Prevent touch scrolling */
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            align-items: center;
        }

        .btn-action {
            background: linear-gradient(135deg, #00b894 0%, #00cec9 100%);
            box-shadow: 0 4px 15px rgba(0, 184, 148, 0.4);
        }

        .btn-undo {
            background: linear-gradient(135deg, #fdcb6e 0%, #e17055 100%);
            box-shadow: 0 4px 15px rgba(253, 203, 110, 0.4);
        }

        .mode-indicator {
            background: #e3f2fd;
            padding: 10px 20px;
            border-radius: 50px;
            font-weight: 600;
            color: #1976d2;
            display: inline-block;
        }

        .attempts-remaining {
            background: #ff6b6b;
            color: white;
            padding: 8px 20px;
            border-radius: 50px;
            font-weight: 600;
            display: inline-block;
        }

        .feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            text-align: center;
            z-index: 1000;
            min-width: 300px;
            display: none;
        }

        .feedback.show {
            display: block;
            animation: slideIn 0.3s ease-out;
        }

        .feedback.correct {
            border: 5px solid #2ecc71;
        }

        .feedback.incorrect {
            border: 5px solid #e74c3c;
        }

        .feedback h2 {
            font-size: 2.5em;
            margin-bottom: 15px;
        }

        .feedback.correct h2 {
            color: #2ecc71;
        }

        .feedback.incorrect h2 {
            color: #e74c3c;
        }

        .feedback p {
            font-size: 1.2em;
            color: #636e72;
        }

        .results-summary {
            background: #f8f9fa;
            padding: 30px;
            border-radius: 15px;
            margin: 20px 0;
        }

        .results-summary h3 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.8em;
        }

        .result-stat {
            display: flex;
            justify-content: space-between;
            padding: 15px;
            margin: 10px 0;
            background: white;
            border-radius: 10px;
            border-left: 5px solid #667eea;
        }

        .result-stat-label {
            font-weight: 600;
            color: #2d3436;
        }

        .result-stat-value {
            font-size: 1.3em;
            color: #667eea;
            font-weight: 700;
        }

        .mistakes-list {
            background: #fff3cd;
            padding: 20px;
            border-radius: 15px;
            margin-top: 20px;
            border-left: 5px solid #ffc107;
        }

        .mistakes-list h4 {
            color: #856404;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .mistakes-list ul {
            margin-left: 20px;
        }

        .mistakes-list li {
            color: #856404;
            margin: 10px 0;
            line-height: 1.6;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
                width: 100%;
                border-radius: 10px;
            }

            .title {
                font-size: 1.8em;
            }

            .subtitle {
                font-size: 1em;
            }

            .game-header {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }

            .stats {
                flex-wrap: wrap;
                justify-content: space-around;
                gap: 15px;
            }

            .stat {
                font-size: 0.95em;
            }

            .stat-value {
                font-size: 1.2em;
            }

            .timer {
                text-align: center;
                font-size: 1.1em;
                padding: 8px 20px;
            }

            .game-controls {
                justify-content: center;
            }

            .btn-small {
                padding: 10px 18px;
                font-size: 0.95em;
            }

            canvas {
                width: 100% !important;
                height: auto !important;
                max-width: 100%;
            }

            .canvas-container {
                padding: 10px;
            }

            .instructions, .ray-info {
                padding: 15px;
                font-size: 0.95em;
            }

            .instructions ul, .ray-info p {
                font-size: 0.9em;
            }

            .btn {
                padding: 12px 30px;
                font-size: 1em;
            }

            .mode-indicator {
                font-size: 0.9em;
                padding: 8px 15px;
            }

            .attempts-remaining {
                font-size: 0.85em;
                padding: 6px 15px;
            }

            .action-buttons {
                gap: 10px;
            }

            .feedback {
                width: 90%;
                padding: 25px;
            }

            .feedback h2 {
                font-size: 2em;
            }

            .feedback p {
                font-size: 1em;
            }

            .results-summary {
                padding: 20px;
            }

            .result-stat {
                flex-direction: column;
                gap: 5px;
                padding: 12px;
            }

            .result-stat-value {
                font-size: 1.5em;
            }

            .mistakes-list {
                padding: 15px;
            }
        }

        @media (max-width: 480px) {
            .title {
                font-size: 1.5em;
            }

            .stats {
                gap: 10px;
            }

            .stat {
                font-size: 0.85em;
            }

            .instructions h3 {
                font-size: 1.2em;
            }

            .ray-info h4 {
                font-size: 1.1em;
            }
        }

        @media (max-height: 600px) and (orientation: landscape) {
            .container {
                padding: 10px;
                max-height: 95vh;
                overflow-y: auto;
            }

            .title {
                font-size: 1.5em;
                margin-bottom: 10px;
            }

            .subtitle {
                font-size: 0.9em;
                margin-bottom: 15px;
            }

            .instructions, .ray-info {
                padding: 10px;
                margin-bottom: 10px;
            }

            .game-header {
                margin-bottom: 10px;
            }

            .canvas-container {
                padding: 10px;
                margin-bottom: 10px;
            }

            .question-info {
                padding: 8px;
                margin-bottom: 10px;
            }

            .btn {
                padding: 10px 25px;
                font-size: 1em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Intro Screen -->
        <div class="intro-screen active">
            <h1 class="title">ðŸ”¬ Lens Ray Diagram Game</h1>
            <p class="subtitle">Master the art of drawing ray diagrams!</p>
            
            <div class="instructions">
                <h3>ðŸ“‹ How to Play</h3>
                <ul>
                    <li><strong>Goal:</strong> Complete as many ray diagrams as possible in 5 minutes!</li>
                    <li><strong>Drawing Rays:</strong> Click twice to draw a ray - once at the start, once at the end. Rays snap to the grid.</li>
                    <li><strong>Placing the Image:</strong> After drawing 2+ rays, click "Place Image" and mark the base and top of the image.</li>
                    <li><strong>Scoring:</strong> Get points for correct diagrams. Higher accuracy = bonus points!</li>
                    <li><strong>Attempts:</strong> You get 3 attempts per question. Wrong rays can be deleted.</li>
                    <li><strong>Controls:</strong> Use Undo, Skip, or End Early buttons as needed.</li>
                </ul>
            </div>

            <div class="ray-info">
                <h4>ðŸŒŸ Principal Rays for Convex Lenses:</h4>
                <p><strong>Ray 1:</strong> Parallel to axis â†’ passes through far focal point</p>
                <p><strong>Ray 2:</strong> Through center â†’ continues straight</p>
                <p><strong>Ray 3:</strong> Through near focal point â†’ emerges parallel</p>
                
                <h4 style="margin-top: 15px;">ðŸŒŸ Principal Rays for Concave Lenses:</h4>
                <p><strong>Ray 1:</strong> Parallel to axis â†’ appears from near focal point</p>
                <p><strong>Ray 2:</strong> Through center â†’ continues straight</p>
                <p><strong>Ray 3:</strong> Toward far focal point â†’ emerges parallel</p>
            </div>

            <button class="btn btn-center" onclick="startGame()">Start Game! ðŸš€</button>
        </div>

        <!-- Game Screen -->
        <div class="game-screen">
            <div class="game-header">
                <div class="stats">
                    <div class="stat">
                        <span class="stat-label">Score:</span>
                        <span class="stat-value" id="score">0</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Correct:</span>
                        <span class="stat-value" id="correct">0</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Question:</span>
                        <span class="stat-value" id="questionNum">1</span>
                    </div>
                </div>
                <div class="timer" id="timer">5:00</div>
                <div class="game-controls">
                    <button class="btn btn-small btn-end" onclick="endGame()">End Early</button>
                    <button class="btn btn-small btn-skip" onclick="skipQuestion()">Skip</button>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="gameCanvas"></canvas>
            </div>

            <div class="action-buttons">
                <div class="mode-indicator" id="modeIndicator">Drawing Rays</div>
                <span class="attempts-remaining" id="attemptsIndicator" style="display: none;">Attempts: 3</span>
                <button class="btn btn-small btn-undo" onclick="undoLastRay()" id="undoBtn">â†¶ Undo Ray</button>
                <button class="btn btn-action" onclick="startPlacingImage()" id="placeImageBtn" style="display: none;">Place Image âœ“</button>
            </div>
        </div>

        <!-- Results Screen -->
        <div class="results-screen">
            <h1 class="title">ðŸŽ¯ Game Complete!</h1>
            <p class="subtitle">Here's how you did:</p>

            <div class="results-summary">
                <h3>ðŸ“Š Your Statistics</h3>
                <div class="result-stat">
                    <span class="result-stat-label">Total Score</span>
                    <span class="result-stat-value" id="finalScore">0</span>
                </div>
                <div class="result-stat">
                    <span class="result-stat-label">Questions Attempted</span>
                    <span class="result-stat-value" id="finalAttempted">0</span>
                </div>
                <div class="result-stat">
                    <span class="result-stat-label">Correct Answers</span>
                    <span class="result-stat-value" id="finalCorrect">0</span>
                </div>
                <div class="result-stat">
                    <span class="result-stat-label">Accuracy</span>
                    <span class="result-stat-value" id="finalAccuracy">0%</span>
                </div>
            </div>

            <div class="mistakes-list" id="mistakesList">
                <h4>ðŸ’¡ Common Mistakes</h4>
                <ul id="mistakesUl">
                    <li>No mistakes recorded - great job!</li>
                </ul>
            </div>

            <button class="btn btn-center" onclick="location.reload()">Play Again! ðŸ”„</button>
        </div>

        <!-- Feedback popup -->
        <div class="feedback" id="feedback">
            <h2 id="feedbackTitle">Correct!</h2>
            <p id="feedbackText">Great job!</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let GRID_SIZE = 20;
        
        // Responsive canvas setup
        function resizeCanvas() {
            const container = canvas.parentElement;
            const containerWidth = container.clientWidth - 40; // Account for padding
            
            if (window.innerWidth <= 768) {
                // Mobile
                canvas.width = Math.min(containerWidth, 800);
                canvas.height = Math.min(canvas.width * 0.7, 500);
                GRID_SIZE = canvas.width / 40; // Adaptive grid size
            } else {
                // Desktop
                canvas.width = 1000;
                canvas.height = 600;
                GRID_SIZE = 20;
            }
            
            if (gameState.currentQuestion) {
                drawScene();
            }
        }
        
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('load', resizeCanvas);
        
        let gameState = {
            timeRemaining: 300, // 5 minutes in seconds
            score: 0,
            correctCount: 0,
            questionCount: 0,
            attemptedCount: 0,
            currentQuestion: null,
            rays: [],
            imagePoints: [],
            mode: 'drawingRays', // 'drawingRays' or 'placingImage'
            attemptsRemaining: 3,
            mistakes: [],
            timerInterval: null
        };

        function startGame() {
            document.querySelector('.intro-screen').classList.remove('active');
            document.querySelector('.game-screen').classList.add('active');
            
            resizeCanvas();
            gameState.timerInterval = setInterval(updateTimer, 1000);
            generateQuestion();
        }

        function updateTimer() {
            gameState.timeRemaining--;
            
            const minutes = Math.floor(gameState.timeRemaining / 60);
            const seconds = gameState.timeRemaining % 60;
            const timerEl = document.getElementById('timer');
            timerEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            if (gameState.timeRemaining <= 30) {
                timerEl.classList.add('warning');
            }
            
            if (gameState.timeRemaining <= 0) {
                endGame();
            }
        }

        function generateQuestion() {
            gameState.questionCount++;
            gameState.attemptedCount++;
            gameState.rays = [];
            gameState.imagePoints = [];
            gameState.mode = 'drawingRays';
            gameState.attemptsRemaining = 3;
            
            document.getElementById('questionNum').textContent = gameState.questionCount;
            document.getElementById('placeImageBtn').style.display = 'none';
            document.getElementById('modeIndicator').textContent = 'Drawing Rays';
            document.getElementById('attemptsIndicator').style.display = 'none';
            
            const lensType = Math.random() < 0.5 ? 'convex' : 'concave';
            let focalLength = 50 + Math.floor(Math.random() * 100); // 50-150 units
            focalLength = Math.round(focalLength / GRID_SIZE) * GRID_SIZE; // Snap to grid
            
            let objectDistance, objectHeight;
            
            if (lensType === 'convex') {
                // Avoid object at focal point
                if (Math.random() < 0.3) {
                    // Object inside focal length
                    objectDistance = 20 + Math.floor(Math.random() * (focalLength - 30));
                } else {
                    // Object outside focal length
                    objectDistance = focalLength + 30 + Math.floor(Math.random() * 100);
                }
            } else {
                // Concave lens - any position works
                objectDistance = 50 + Math.floor(Math.random() * 150);
            }
            
            // Snap to grid
            objectDistance = Math.round(objectDistance / GRID_SIZE) * GRID_SIZE;
            objectHeight = 40 + Math.floor(Math.random() * 60);
            objectHeight = Math.round(objectHeight / GRID_SIZE) * GRID_SIZE;
            
            // For convex lenses, check that the image will be on screen
            if (lensType === 'convex') {
                const u = objectDistance;
                const f = focalLength;
                
                if (Math.abs(u - f) > 5) { // Not at focal point
                    const v = (f * u) / (u - f);
                    const imageX = canvas.width / 2 + Math.abs(v);
                    
                    // If image is off screen, regenerate the question
                    if (imageX > canvas.width - 100 || imageX < 100) {
                        // Adjust object distance to bring image on screen
                        if (u > f) {
                            // Real image - limit how far the object can be
                            objectDistance = f + Math.min(100, Math.floor(Math.random() * 80) + 20);
                            objectDistance = Math.round(objectDistance / GRID_SIZE) * GRID_SIZE;
                        }
                    }
                }
            } else {
                // For concave lenses, check that virtual image is on screen
                const u = objectDistance;
                const f = focalLength;
                const v = (f * u) / (u + f);
                const imageX = canvas.width / 2 - Math.abs(v);
                
                // If virtual image is too far left, adjust object distance
                if (imageX < 100) {
                    objectDistance = 50 + Math.floor(Math.random() * 80);
                    objectDistance = Math.round(objectDistance / GRID_SIZE) * GRID_SIZE;
                }
            }
            
            gameState.currentQuestion = {
                lensType,
                focalLength,
                objectDistance,
                objectHeight,
                lensX: canvas.width / 2,
                lensY: canvas.height / 2
            };
            
            drawScene();
        }

        function drawScene() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            for (let x = 0; x <= canvas.width; x += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            const q = gameState.currentQuestion;
            
            // Draw principal axis (dashed)
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 5]);
            ctx.beginPath();
            ctx.moveTo(0, q.lensY);
            ctx.lineTo(canvas.width, q.lensY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw lens
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(q.lensX, q.lensY - 150);
            ctx.lineTo(q.lensX, q.lensY + 150);
            ctx.stroke();
            
            // Draw lens arrows (single arrowheads RIGHT at the ends)
            const arrowSize = 25;
            ctx.fillStyle = '#000';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            
            if (q.lensType === 'convex') {
                // Top arrow pointing up - RIGHT at y-150
                drawLensArrowhead(ctx, q.lensX, q.lensY - 150, 'up', arrowSize);
                // Bottom arrow pointing down - RIGHT at y+150
                drawLensArrowhead(ctx, q.lensX, q.lensY + 150, 'down', arrowSize);
            } else {
                // Concave: Top arrow pointing down - RIGHT at y-150
                drawLensArrowhead(ctx, q.lensX, q.lensY - 150, 'down', arrowSize);
                // Bottom arrow pointing up - RIGHT at y+150
                drawLensArrowhead(ctx, q.lensX, q.lensY + 150, 'up', arrowSize);
            }
            
            // Draw focal points
            const focalPointLeft = q.lensX - q.focalLength;
            const focalPointRight = q.lensX + q.focalLength;
            
            ctx.fillStyle = '#ff6b6b';
            ctx.beginPath();
            ctx.arc(focalPointLeft, q.lensY, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(focalPointRight, q.lensY, 6, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#000';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText('F', focalPointLeft - 5, q.lensY - 10);
            ctx.fillText('F', focalPointRight - 5, q.lensY - 10);
            
            // Draw object (using grid-snapped values from question)
            const objX = q.lensX - q.objectDistance;
            const objY = q.lensY;
            const objHeight = q.objectHeight;
            drawObjectImageArrow(ctx, objX, objY, objX, objY - objHeight, 10, '#2196f3', 3);
            
            ctx.fillStyle = '#2196f3';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText('O', objX - 15, objY + 20);
            
            // Draw rays with extrapolations
            gameState.rays.forEach((ray, index) => {
                const colors = ['#e74c3c', '#2ecc71', '#f39c12'];
                
                // Draw the main ray
                drawRayArrow(ctx, ray.x1, ray.y1, ray.x2, ray.y2, 8, colors[index % 3], 2.5);
                
                // Check if this ray passes through center
                const passesThroughCenter = checkIfRayThroughCenter(ray, q);
                
                // Check if this ray passes through near focal point (concave lenses)
                const passesThroughNearFocal = checkIfRayThroughNearFocalPoint(ray, q);
                
                // Determine if we need extrapolation and what type
                const rayNeedsExtrapolation = shouldExtrapolateRay(ray, q) || passesThroughCenter || passesThroughNearFocal;
                
                if (rayNeedsExtrapolation) {
                    // Calculate extrapolation direction
                    const dx = ray.x2 - ray.x1;
                    const dy = ray.y2 - ray.y1;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const dirX = dx / length;
                    const dirY = dy / length;
                    
                    // Extrapolate to edge of canvas
                    let extrapX, extrapY;
                    
                    if (rayNeedsExtrapolation.type === 'nearFocal') {
                        // Special case for concave lens - ray through near focal point
                        // The ray emerges parallel to the axis
                        // Draw virtual portion from focal point to lens (dotted)
                        // Draw real portion from lens onwards (parallel, solid)
                        
                        const focalX = rayNeedsExtrapolation.focalX;
                        const focalY = rayNeedsExtrapolation.focalY;
                        
                        // Find where ray intersects lens
                        const t = (q.lensX - ray.x1) / (ray.x2 - ray.x1);
                        const yAtLens = ray.y1 + t * (ray.y2 - ray.y1);
                        
                        // Draw virtual portion (focal point to lens) as dotted
                        if (ray.x1 < q.lensX) {
                            ctx.strokeStyle = colors[index % 3];
                            ctx.lineWidth = 2;
                            ctx.setLineDash([5, 5]);
                            ctx.beginPath();
                            ctx.moveTo(focalX, focalY);
                            ctx.lineTo(q.lensX, yAtLens);
                            ctx.stroke();
                            ctx.setLineDash([]);
                        }
                        
                        // Draw real portion (from lens, parallel to axis) as solid
                        extrapX = canvas.width;
                        extrapY = yAtLens; // Parallel to axis, so y stays constant
                        
                        ctx.strokeStyle = colors[index % 3];
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(q.lensX, yAtLens);
                        ctx.lineTo(extrapX, extrapY);
                        ctx.stroke();
                        
                    } else if (rayNeedsExtrapolation.type === 'center') {
                        // Center ray continues straight - extrapolate forward
                        const extrapLength = 500;
                        extrapX = ray.x2 + dirX * extrapLength;
                        extrapY = ray.y2 + dirY * extrapLength;
                        
                        // Draw solid line for center ray extension
                        ctx.strokeStyle = colors[index % 3];
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(ray.x2, ray.y2);
                        ctx.lineTo(extrapX, extrapY);
                        ctx.stroke();
                    } else if (rayNeedsExtrapolation.type === 'virtual') {
                        // Extrapolate backwards from ray start
                        const extrapLength = 500;
                        extrapX = ray.x1 - dirX * extrapLength;
                        extrapY = ray.y1 - dirY * extrapLength;
                        
                        // Draw dotted line for virtual ray
                        ctx.strokeStyle = colors[index % 3];
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.moveTo(ray.x1, ray.y1);
                        ctx.lineTo(extrapX, extrapY);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    } else {
                        // Extrapolate forwards from ray end (real ray extension)
                        const extrapLength = 500;
                        extrapX = ray.x2 + dirX * extrapLength;
                        extrapY = ray.y2 + dirY * extrapLength;
                        
                        // Draw solid line for real ray extension
                        ctx.strokeStyle = colors[index % 3];
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(ray.x2, ray.y2);
                        ctx.lineTo(extrapX, extrapY);
                        ctx.stroke();
                    }
                }
            });
            
            // Draw image points if in placing mode
            if (gameState.mode === 'placingImage' && gameState.imagePoints.length > 0) {
                gameState.imagePoints.forEach(point => {
                    ctx.fillStyle = '#9b59b6';
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                if (gameState.imagePoints.length === 2) {
                    drawObjectImageArrow(ctx, 
                        gameState.imagePoints[0].x, gameState.imagePoints[0].y,
                        gameState.imagePoints[1].x, gameState.imagePoints[1].y,
                        10, '#9b59b6', 3);
                }
            }
        }

        function checkIfRayThroughCenter(ray, q) {
            // Check if ray passes through the center of the lens
            const tolerance = GRID_SIZE * 1.5; // Slightly more lenient for ray paths
            
            // Check if ray passes through lens center (lensX, lensY)
            // We can check if the ray crosses the lens line near the center
            if (Math.abs(ray.x1 - q.lensX) < tolerance || Math.abs(ray.x2 - q.lensX) < tolerance) {
                // Ray is near lens, check if it passes through center
                // Calculate y-value at lensX
                const t = (q.lensX - ray.x1) / (ray.x2 - ray.x1);
                const yAtLens = ray.y1 + t * (ray.y2 - ray.y1);
                
                if (Math.abs(yAtLens - q.lensY) < tolerance) {
                    return { type: 'center' };
                }
            }
            
            return null;
        }

        function checkIfRayThroughNearFocalPoint(ray, q) {
            // For concave lenses, check if ray passes through (or appears to come from) the near focal point
            if (q.lensType !== 'concave') {
                return null;
            }
            
            const tolerance = GRID_SIZE * 1.5;
            const nearFocalX = q.lensX - q.focalLength;
            const nearFocalY = q.lensY;
            
            // Check if the ray, when extrapolated backwards, passes through the near focal point
            // Calculate where the ray would be at nearFocalX
            if (ray.x1 !== ray.x2) { // Avoid division by zero
                const t = (nearFocalX - ray.x1) / (ray.x2 - ray.x1);
                const yAtFocal = ray.y1 + t * (ray.y2 - ray.y1);
                
                if (Math.abs(yAtFocal - nearFocalY) < tolerance) {
                    // Ray passes through or near the near focal point
                    return { 
                        type: 'nearFocal',
                        focalX: nearFocalX,
                        focalY: nearFocalY
                    };
                }
            }
            
            return null;
        }

        function shouldExtrapolateRay(ray, q) {
            // Determine if this ray needs extrapolation
            // For concave lenses, rays diverge and need virtual extrapolation
            // For convex lenses with object inside focal length, rays diverge and need virtual extrapolation
            // For convex lenses with object outside focal length, rays converge and may need real extrapolation
            
            const tolerance = GRID_SIZE * 1.5;
            
            if (q.lensType === 'concave') {
                // Concave lenses always produce virtual images
                // Check if ray is going away from lens on object side
                if (ray.x2 > q.lensX - tolerance) {
                    // Ray has passed through or reached lens, needs virtual extrapolation backwards
                    return { type: 'virtual' };
                }
            } else {
                // Convex lens
                if (q.objectDistance < q.focalLength) {
                    // Object inside focal length - virtual image
                    // Rays diverge after lens, need virtual extrapolation backwards
                    if (ray.x2 > q.lensX - tolerance) {
                        return { type: 'virtual' };
                    }
                } else {
                    // Object outside focal length - real image
                    // Rays converge after lens, may need real extrapolation forwards
                    if (ray.x2 > q.lensX + tolerance) {
                        return { type: 'real' };
                    }
                }
            }
            
            return null;
        }

        function drawLensArrowhead(ctx, x, y, direction, size) {
            ctx.fillStyle = '#000';
            ctx.beginPath();
            
            if (direction === 'up') {
                // Arrow pointing up
                ctx.moveTo(x, y - size);
                ctx.lineTo(x - size/2, y);
                ctx.lineTo(x + size/2, y);
            } else if (direction === 'down') {
                // Arrow pointing down
                ctx.moveTo(x, y + size);
                ctx.lineTo(x - size/2, y);
                ctx.lineTo(x + size/2, y);
            }
            
            ctx.closePath();
            ctx.fill();
        }

        function drawObjectImageArrow(ctx, x1, y1, x2, y2, arrowSize, color, lineWidth = 2) {
            // For object/image arrows - arrowhead at the END (away from principal axis)
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = lineWidth;
            
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            
            // Draw arrowhead at end point
            const angle = Math.atan2(y2 - y1, x2 - x1);
            
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - arrowSize * Math.cos(angle - Math.PI / 6), 
                       y2 - arrowSize * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(x2 - arrowSize * Math.cos(angle + Math.PI / 6), 
                       y2 - arrowSize * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
        }

        function drawRayArrow(ctx, x1, y1, x2, y2, arrowSize, color, lineWidth = 2) {
            // For rays - arrowhead at midpoint
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = lineWidth;
            
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            
            // Draw arrowhead at midpoint
            const midX = (x1 + x2) / 2;
            const midY = (y1 + y2) / 2;
            const angle = Math.atan2(y2 - y1, x2 - x1);
            
            ctx.beginPath();
            ctx.moveTo(midX, midY);
            ctx.lineTo(midX - arrowSize * Math.cos(angle - Math.PI / 6), 
                       midY - arrowSize * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(midX - arrowSize * Math.cos(angle + Math.PI / 6), 
                       midY - arrowSize * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
        }

        function snapToGrid(x, y) {
            return {
                x: Math.round(x / GRID_SIZE) * GRID_SIZE,
                y: Math.round(y / GRID_SIZE) * GRID_SIZE
            };
        }

        let clickCount = 0;
        let firstClick = null;

        function handleCanvasInteraction(e) {
            e.preventDefault(); // Prevent default touch behavior
            
            const rect = canvas.getBoundingClientRect();
            let x, y;
            
            if (e.type.startsWith('touch')) {
                const touch = e.touches[0] || e.changedTouches[0];
                x = touch.clientX - rect.left;
                y = touch.clientY - rect.top;
            } else {
                x = e.clientX - rect.left;
                y = e.clientY - rect.top;
            }
            
            // Scale coordinates for responsive canvas
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            x *= scaleX;
            y *= scaleY;
            
            const snapped = snapToGrid(x, y);
            
            if (gameState.mode === 'drawingRays') {
                if (clickCount === 0) {
                    firstClick = snapped;
                    clickCount = 1;
                    
                    // Visual feedback for first click
                    ctx.fillStyle = 'rgba(102, 126, 234, 0.5)';
                    ctx.beginPath();
                    ctx.arc(snapped.x, snapped.y, 10, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Complete the ray
                    gameState.rays.push({
                        x1: firstClick.x,
                        y1: firstClick.y,
                        x2: snapped.x,
                        y2: snapped.y
                    });
                    clickCount = 0;
                    firstClick = null;
                    
                    if (gameState.rays.length >= 2) {
                        document.getElementById('placeImageBtn').style.display = 'inline-block';
                    }
                    
                    drawScene();
                }
            } else if (gameState.mode === 'placingImage') {
                gameState.imagePoints.push(snapped);
                
                if (gameState.imagePoints.length === 2) {
                    checkAnswer();
                }
                
                drawScene();
            }
        }

        // Add both click and touch event listeners
        canvas.addEventListener('click', handleCanvasInteraction);
        canvas.addEventListener('touchend', handleCanvasInteraction);
        
        // Prevent scrolling when touching the canvas
        canvas.addEventListener('touchstart', (e) => e.preventDefault());
        canvas.addEventListener('touchmove', (e) => e.preventDefault());

        function undoLastRay() {
            if (gameState.rays.length > 0) {
                gameState.rays.pop();
                if (gameState.rays.length < 2) {
                    document.getElementById('placeImageBtn').style.display = 'none';
                }
                drawScene();
            }
            clickCount = 0;
            firstClick = null;
        }

        function startPlacingImage() {
            gameState.mode = 'placingImage';
            gameState.imagePoints = [];
            document.getElementById('modeIndicator').textContent = 'Placing Image (click base, then top)';
            document.getElementById('placeImageBtn').style.display = 'none';
        }

        function calculateImagePosition() {
            const q = gameState.currentQuestion;
            const u = q.objectDistance;
            const f = q.focalLength;
            
            let v, m, imageHeight;
            
            if (q.lensType === 'convex') {
                if (Math.abs(u - f) < 5) {
                    // At focal point - no real image
                    return null;
                }
                
                v = (f * u) / (u - f);
                m = v / u;
                imageHeight = m * q.objectHeight;
                
                return {
                    distance: Math.abs(v),
                    height: Math.abs(imageHeight),
                    isReal: v > 0,
                    isInverted: v > 0,
                    side: v > 0 ? 'right' : 'left'
                };
            } else {
                // Concave lens
                v = (f * u) / (u + f);
                m = v / u;
                imageHeight = m * q.objectHeight;
                
                return {
                    distance: Math.abs(v),
                    height: Math.abs(imageHeight),
                    isReal: false,
                    isInverted: false,
                    side: 'left'
                };
            }
        }

        function checkAnswer() {
            const q = gameState.currentQuestion;
            const correctImage = calculateImagePosition();
            
            if (!correctImage) {
                // No image case (object at focal point of convex lens)
                showFeedback(false, "No real image is formed when object is at the focal point!");
                return;
            }
            
            // Calculate expected image position (grid-snapped)
            let expectedImageX;
            if (correctImage.side === 'right') {
                expectedImageX = q.lensX + correctImage.distance;
            } else {
                expectedImageX = q.lensX - correctImage.distance;
            }
            
            // Snap to grid
            expectedImageX = Math.round(expectedImageX / GRID_SIZE) * GRID_SIZE;
            
            const expectedImageY1 = q.lensY;
            let expectedImageY2 = correctImage.isInverted ? 
                q.lensY + correctImage.height : 
                q.lensY - correctImage.height;
            
            // Snap to grid
            expectedImageY2 = Math.round(expectedImageY2 / GRID_SIZE) * GRID_SIZE;
            
            // Check user's image points
            const userPoints = gameState.imagePoints;
            
            // Determine which point is base and which is top
            let basePoint, topPoint;
            if (Math.abs(userPoints[0].y - q.lensY) < Math.abs(userPoints[1].y - q.lensY)) {
                basePoint = userPoints[0];
                topPoint = userPoints[1];
            } else {
                basePoint = userPoints[1];
                topPoint = userPoints[0];
            }
            
            // Check if image position is correct (everything is grid-snapped, so must match exactly)
            const tolerance = 5; // Just a few pixels for floating point tolerance
            const xCorrect = Math.abs(basePoint.x - expectedImageX) < tolerance;
            const baseYCorrect = Math.abs(basePoint.y - expectedImageY1) < tolerance;
            const topYCorrect = Math.abs(topPoint.y - expectedImageY2) < tolerance;
            const topXCorrect = Math.abs(topPoint.x - expectedImageX) < tolerance;
            
            const imageCorrect = xCorrect && baseYCorrect && topYCorrect && topXCorrect;
            
            // Check rays (simplified - just check if there are at least 2)
            const raysCorrect = gameState.rays.length >= 2;
            
            if (imageCorrect && raysCorrect) {
                // Correct!
                const basePoints = 100;
                const accuracyBonus = gameState.attemptsRemaining === 3 ? 50 : 
                                     gameState.attemptsRemaining === 2 ? 25 : 0;
                const totalPoints = basePoints + accuracyBonus;
                
                gameState.score += totalPoints;
                gameState.correctCount++;
                
                document.getElementById('score').textContent = gameState.score;
                document.getElementById('correct').textContent = gameState.correctCount;
                
                showFeedback(true, `+${totalPoints} points!`);
                setTimeout(() => {
                    generateQuestion();
                }, 2000);
            } else {
                gameState.attemptsRemaining--;
                
                let errorMsg = 'Not quite right. ';
                
                if (!imageCorrect) {
                    const xError = Math.abs(basePoint.x - expectedImageX);
                    const yError = Math.abs(topPoint.y - expectedImageY2);
                    errorMsg += `Image position is off. `;
                    gameState.mistakes.push('Image position incorrect');
                }
                
                if (gameState.attemptsRemaining > 0) {
                    errorMsg += `${gameState.attemptsRemaining} attempts remaining.`;
                    showFeedback(false, errorMsg);
                    gameState.mode = 'drawingRays';
                    gameState.imagePoints = [];
                    document.getElementById('modeIndicator').textContent = 'Drawing Rays - Try Again';
                    document.getElementById('attemptsIndicator').style.display = 'inline-block';
                    document.getElementById('attemptsIndicator').textContent = `Attempts: ${gameState.attemptsRemaining}`;
                    drawScene();
                } else {
                    showFeedback(false, "Out of attempts. Moving to next question.");
                    setTimeout(() => {
                        generateQuestion();
                    }, 2000);
                }
            }
        }

        function showFeedback(isCorrect, message) {
            const feedback = document.getElementById('feedback');
            const title = document.getElementById('feedbackTitle');
            const text = document.getElementById('feedbackText');
            
            feedback.className = 'feedback show ' + (isCorrect ? 'correct' : 'incorrect');
            title.textContent = isCorrect ? 'âœ“ Correct!' : 'âœ— Incorrect';
            text.textContent = message;
            
            setTimeout(() => {
                feedback.classList.remove('show');
            }, isCorrect ? 2000 : 3000);
        }

        function skipQuestion() {
            gameState.mistakes.push('Question skipped');
            generateQuestion();
        }

        function endGame() {
            clearInterval(gameState.timerInterval);
            
            document.querySelector('.game-screen').classList.remove('active');
            document.querySelector('.results-screen').classList.add('active');
            
            const accuracy = gameState.attemptedCount > 0 ? 
                Math.round((gameState.correctCount / gameState.attemptedCount) * 100) : 0;
            
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('finalAttempted').textContent = gameState.attemptedCount;
            document.getElementById('finalCorrect').textContent = gameState.correctCount;
            document.getElementById('finalAccuracy').textContent = accuracy + '%';
            
            // Show mistakes
            const mistakesUl = document.getElementById('mistakesUl');
            if (gameState.mistakes.length > 0) {
                const mistakeCounts = {};
                gameState.mistakes.forEach(m => {
                    mistakeCounts[m] = (mistakeCounts[m] || 0) + 1;
                });
                
                mistakesUl.innerHTML = '';
                Object.entries(mistakeCounts).forEach(([mistake, count]) => {
                    const li = document.createElement('li');
                    li.textContent = `${mistake} (${count} time${count > 1 ? 's' : ''})`;
                    mistakesUl.appendChild(li);
                });
            } else {
                mistakesUl.innerHTML = '<li>No mistakes recorded - perfect performance!</li>';
            }
        }
    </script>
</body>
</html>
