<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Lens Ray Diagram Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #2d3436;
            overflow-x: hidden;
            touch-action: pan-y;
            -webkit-tap-highlight-color: transparent;
        }

        .container {
            width: 95%;
            max-width: 1200px;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
            animation: slideIn 0.5s ease-out;
        }

        .intro-screen, .game-screen, .results-screen {
            display: none;
        }

        .intro-screen.active, .game-screen.active, .results-screen.active {
            display: block;
        }

        .title {
            text-align: center;
            font-size: 2.8em;
            font-weight: 800;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 20px;
            letter-spacing: -1px;
        }

        .subtitle {
            text-align: center;
            font-size: 1.2em;
            color: #636e72;
            margin-bottom: 30px;
        }

        .instructions {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 20px;
            line-height: 1.8;
            border-left: 5px solid #667eea;
        }

        .instructions h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.4em;
        }

        .instructions ul {
            margin-left: 20px;
        }

        .instructions li {
            margin: 10px 0;
            color: #2d3436;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.2em;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            min-height: 44px;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-center {
            display: block;
            margin: 0 auto;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .stats {
            display: flex;
            gap: 30px;
            align-items: center;
        }

        .stat {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1.1em;
            font-weight: 600;
        }

        .stat-label {
            color: #636e72;
        }

        .stat-value {
            color: #667eea;
            font-size: 1.3em;
        }

        .timer {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
            color: white;
            padding: 10px 25px;
            border-radius: 50px;
            font-size: 1.3em;
            font-weight: 700;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
        }

        .timer.warning {
            animation: pulse 1s infinite;
        }

        .game-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn-small {
            padding: 8px 20px;
            font-size: 1em;
            background: #74b9ff;
            box-shadow: 0 2px 10px rgba(116, 185, 255, 0.4);
            min-height: 44px;
        }

        .btn-skip {
            background: linear-gradient(135deg, #ffa502 0%, #ff6348 100%);
            box-shadow: 0 2px 10px rgba(255, 165, 2, 0.4);
        }

        .btn-end {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
            box-shadow: 0 2px 10px rgba(255, 107, 107, 0.4);
        }

        .canvas-container {
            position: relative;
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        canvas {
            border: 2px solid #dfe6e9;
            border-radius: 10px;
            cursor: crosshair;
            display: block;
            margin: 0 auto;
            background: #fafbfc;
            max-width: 100%;
            touch-action: none;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            align-items: center;
        }

        .btn-action {
            background: linear-gradient(135deg, #00b894 0%, #00cec9 100%);
            box-shadow: 0 4px 15px rgba(0, 184, 148, 0.4);
        }

        .btn-undo {
            background: linear-gradient(135deg, #fdcb6e 0%, #e17055 100%);
            box-shadow: 0 4px 15px rgba(253, 203, 110, 0.4);
        }

        .mode-indicator {
            background: #e3f2fd;
            padding: 10px 20px;
            border-radius: 50px;
            font-weight: 600;
            color: #1976d2;
            display: inline-block;
        }

        .attempts-remaining {
            background: #ff6b6b;
            color: white;
            padding: 8px 20px;
            border-radius: 50px;
            font-weight: 600;
            display: inline-block;
        }

        .feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            text-align: center;
            z-index: 1000;
            min-width: 300px;
            max-width: 500px;
            display: none;
        }

        .feedback.show {
            display: block;
            animation: slideIn 0.3s ease-out;
        }

        .feedback.correct {
            border: 5px solid #2ecc71;
        }

        .feedback.incorrect {
            border: 5px solid #e74c3c;
        }

        .feedback h2 {
            font-size: 2.5em;
            margin-bottom: 15px;
        }

        .feedback.correct h2 {
            color: #2ecc71;
        }

        .feedback.incorrect h2 {
            color: #e74c3c;
        }

        .feedback p {
            font-size: 1.1em;
            color: #636e72;
            margin: 10px 0;
            line-height: 1.6;
            text-align: left;
        }

        .feedback ul {
            text-align: left;
            margin: 15px 0;
            padding-left: 20px;
        }

        .feedback li {
            margin: 8px 0;
            color: #e74c3c;
        }

        .results-summary {
            background: #f8f9fa;
            padding: 30px;
            border-radius: 15px;
            margin: 20px 0;
        }

        .results-summary h3 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.8em;
        }

        .result-stat {
            display: flex;
            justify-content: space-between;
            padding: 15px;
            margin: 10px 0;
            background: white;
            border-radius: 10px;
            border-left: 5px solid #667eea;
        }

        .result-stat-label {
            font-weight: 600;
            color: #2d3436;
        }

        .result-stat-value {
            font-size: 1.3em;
            color: #667eea;
            font-weight: 700;
        }

        .mistakes-list {
            background: #fff3cd;
            padding: 20px;
            border-radius: 15px;
            margin-top: 20px;
            border-left: 5px solid #ffc107;
        }

        .mistakes-list h4 {
            color: #856404;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .mistakes-list ul {
            margin-left: 20px;
        }

        .mistakes-list li {
            color: #856404;
            margin: 10px 0;
            line-height: 1.6;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
                width: 100%;
                border-radius: 10px;
            }

            .title {
                font-size: 1.8em;
            }

            .subtitle {
                font-size: 1em;
            }

            .game-header {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }

            .stats {
                flex-wrap: wrap;
                justify-content: space-around;
                gap: 15px;
            }

            .canvas-container {
                padding: 10px;
            }

            .feedback {
                width: 90%;
                padding: 25px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Intro Screen -->
        <div class="intro-screen active">
            <h1 class="title">ðŸ”¬ Lens Ray Diagram Game</h1>
            <p class="subtitle">Master the art of drawing ray diagrams!</p>
            
            <div class="instructions">
                <h3>ðŸ“‹ How to Play</h3>
                <ul>
                    <li><strong>Goal:</strong> Complete as many ray diagrams as possible in 5 minutes!</li>
                    <li><strong>Drawing Rays:</strong> Click twice to draw a ray. Draw at least 2 rays to locate the image.</li>
                    <li><strong>Placing the Image:</strong> After drawing rays, click "Place Image" and mark base and top.</li>
                    <li><strong>Scoring:</strong> Correct image = 100 points. Bonus points for accuracy and perfect rays!</li>
                    <li><strong>Attempts:</strong> You get 3 attempts per question.</li>
                </ul>
            </div>

            <button class="btn btn-center" onclick="startGame()">Start Game! ðŸš€</button>
        </div>

        <!-- Game Screen -->
        <div class="game-screen">
            <div class="game-header">
                <div class="stats">
                    <div class="stat">
                        <span class="stat-label">Score:</span>
                        <span class="stat-value" id="score">0</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Correct:</span>
                        <span class="stat-value" id="correct">0</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Question:</span>
                        <span class="stat-value" id="questionNum">1</span>
                    </div>
                </div>
                <div class="timer" id="timer">5:00</div>
                <div class="game-controls">
                    <button class="btn btn-small btn-end" onclick="endGame()">End Early</button>
                    <button class="btn btn-small btn-skip" onclick="skipQuestion()">Skip</button>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="gameCanvas"></canvas>
            </div>

            <div class="action-buttons">
                <div class="mode-indicator" id="modeIndicator">Drawing Rays (Draw 3 rays)</div>
                <span class="attempts-remaining" id="attemptsIndicator" style="display: none;">Attempts: 3</span>
                <button class="btn btn-small btn-undo" onclick="undoLastRay()" id="undoBtn">â†¶ Undo Ray</button>
                <button class="btn btn-action" onclick="startPlacingImage()" id="placeImageBtn" style="display: none;">Place Image âœ“</button>
                <button class="btn btn-small btn-skip" onclick="cancelPlacingImage()" id="cancelImageBtn" style="display: none;">âœ— Cancel</button>
            </div>
        </div>

        <!-- Results Screen -->
        <div class="results-screen">
            <h1 class="title">ðŸŽ¯ Game Complete!</h1>
            <p class="subtitle">Here's how you did:</p>

            <div class="results-summary">
                <h3>ðŸ“Š Your Statistics</h3>
                <div class="result-stat">
                    <span class="result-stat-label">Total Score</span>
                    <span class="result-stat-value" id="finalScore">0</span>
                </div>
                <div class="result-stat">
                    <span class="result-stat-label">Questions Attempted</span>
                    <span class="result-stat-value" id="finalAttempted">0</span>
                </div>
                <div class="result-stat">
                    <span class="result-stat-label">Correct Answers</span>
                    <span class="result-stat-value" id="finalCorrect">0</span>
                </div>
                <div class="result-stat">
                    <span class="result-stat-label">Accuracy</span>
                    <span class="result-stat-value" id="finalAccuracy">0%</span>
                </div>
            </div>

            <div class="mistakes-list" id="mistakesList">
                <h4>ðŸ’¡ Common Mistakes</h4>
                <ul id="mistakesUl">
                    <li>No mistakes recorded - great job!</li>
                </ul>
            </div>

            <button class="btn btn-center" onclick="location.reload()">Play Again! ðŸ”„</button>
        </div>

        <!-- Feedback popup -->
        <div class="feedback" id="feedback">
            <h2 id="feedbackTitle">Correct!</h2>
            <p id="feedbackText">Great job!</p>
            <ul id="feedbackRayErrors" style="display: none;"></ul>
        </div>
    </div>

    <script>
        let canvas, ctx, GRID_SIZE = 20;
        let gameState;
        let clickCount = 0;
        let firstClick = null;
        
        document.addEventListener('DOMContentLoaded', function() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            gameState = {
                timeRemaining: 300,
                score: 0,
                correctCount: 0,
                questionCount: 0,
                attemptedCount: 0,
                currentQuestion: null,
                rays: [],
                imagePoints: [],
                mode: 'drawingRays',
                attemptsRemaining: 3,
                mistakes: [],
                timerInterval: null
            };
            
            window.addEventListener('resize', resizeCanvas);
            
            canvas.addEventListener('click', handleCanvasInteraction);
            canvas.addEventListener('touchend', handleCanvasInteraction);
            canvas.addEventListener('touchstart', (e) => e.preventDefault());
            canvas.addEventListener('touchmove', (e) => e.preventDefault());
        });
        
        function resizeCanvas() {
            const container = canvas.parentElement;
            const containerWidth = container.clientWidth - 40;
            
            if (window.innerWidth <= 768) {
                canvas.width = Math.min(containerWidth, 800);
                canvas.height = Math.min(canvas.width * 0.75, 600);
                GRID_SIZE = Math.max(canvas.width / 30, 20);
            } else {
                canvas.width = 1000;
                canvas.height = 600;
                GRID_SIZE = 20;
            }
            
            if (gameState && gameState.currentQuestion) {
                drawScene();
            }
        }

        function startGame() {
            document.querySelector('.intro-screen').classList.remove('active');
            document.querySelector('.game-screen').classList.add('active');
            
            resizeCanvas();
            gameState.timerInterval = setInterval(updateTimer, 1000);
            generateQuestion();
        }

        function updateTimer() {
            gameState.timeRemaining--;
            
            const minutes = Math.floor(gameState.timeRemaining / 60);
            const seconds = gameState.timeRemaining % 60;
            const timerEl = document.getElementById('timer');
            timerEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            if (gameState.timeRemaining <= 30) {
                timerEl.classList.add('warning');
            }
            
            if (gameState.timeRemaining <= 0) {
                endGame();
            }
        }

        function generateQuestion() {
            gameState.questionCount++;
            gameState.attemptedCount++;
            gameState.rays = [];
            gameState.imagePoints = [];
            gameState.mode = 'drawingRays';
            gameState.attemptsRemaining = 3;
            
            document.getElementById('questionNum').textContent = gameState.questionCount;
            document.getElementById('placeImageBtn').style.display = 'none';
            document.getElementById('cancelImageBtn').style.display = 'none';
            document.getElementById('modeIndicator').textContent = 'Drawing Rays (Draw at least 2)';
            document.getElementById('attemptsIndicator').style.display = 'none';
            
            const lensType = Math.random() < 0.5 ? 'convex' : 'concave';
            
            const maxFocalLength = Math.min((canvas.width / 2) * 0.4, 150);
            const minFocalLength = Math.max(GRID_SIZE * 2, 50);
            
            let focalLength = minFocalLength + Math.floor(Math.random() * (maxFocalLength - minFocalLength));
            focalLength = Math.round(focalLength / GRID_SIZE) * GRID_SIZE;
            
            const maxObjectDistance = (canvas.width / 2) * 0.5;
            let objectDistance;
            
            if (lensType === 'convex') {
                if (Math.random() < 0.5) {
                    objectDistance = GRID_SIZE * 2 + Math.floor(Math.random() * (focalLength - GRID_SIZE * 4));
                } else {
                    objectDistance = focalLength + GRID_SIZE * 2 + Math.floor(Math.random() * Math.min(100, maxObjectDistance - focalLength));
                }
            } else {
                objectDistance = GRID_SIZE * 3 + Math.floor(Math.random() * Math.min(150, maxObjectDistance));
            }
            
            objectDistance = Math.round(objectDistance / GRID_SIZE) * GRID_SIZE;
            
            const maxInitialHeight = Math.min((canvas.height / 2) * 0.3, 60);
            const minInitialHeight = GRID_SIZE * 2;
            
            let objectHeight = minInitialHeight + Math.floor(Math.random() * (maxInitialHeight - minInitialHeight));
            objectHeight = Math.round(objectHeight / GRID_SIZE) * GRID_SIZE;
            
            const maxObjectHeight = (canvas.height / 2) - GRID_SIZE * 5;
            if (objectHeight > maxObjectHeight) {
                objectHeight = Math.round(maxObjectHeight / GRID_SIZE) * GRID_SIZE;
            }
            
            // Validate image will be on screen
            if (lensType === 'convex') {
                const u = objectDistance;
                const f = focalLength;
                
                const maxImageDistance = (canvas.width / 2) - GRID_SIZE * 3;
                
                if (Math.abs(u - f) > 5) {
                    const v = (f * u) / (u - f);
                    const m = v / u;
                    const imageHeight = Math.abs(m * objectHeight);
                    
                    if (u > f) {
                        const imageDistance = Math.abs(v);
                        
                        if (imageDistance > maxImageDistance || imageHeight > (canvas.height / 2) - GRID_SIZE * 3) {
                            objectDistance = f + Math.min(focalLength * 0.8, 60);
                            objectDistance = Math.round(objectDistance / GRID_SIZE) * GRID_SIZE;
                        }
                    } else {
                        const imageDistance = Math.abs(v);
                        
                        if (imageDistance > maxImageDistance || imageHeight > (canvas.height / 2) - GRID_SIZE * 3) {
                            objectDistance = Math.max(focalLength * 0.3, GRID_SIZE * 2);
                            objectDistance = Math.round(objectDistance / GRID_SIZE) * GRID_SIZE;
                        }
                    }
                }
            } else {
                const u = objectDistance;
                const f = focalLength;
                const v = (f * u) / (u + f);
                const m = v / u;
                const imageHeight = Math.abs(m * objectHeight);
                const imageDistance = Math.abs(v);
                
                const maxImageDistance = (canvas.width / 2) - GRID_SIZE * 3;
                
                if (imageDistance > maxImageDistance || imageHeight > (canvas.height / 2) - GRID_SIZE * 3) {
                    objectDistance = Math.min(focalLength * 1.5, 80);
                    objectDistance = Math.round(objectDistance / GRID_SIZE) * GRID_SIZE;
                }
            }
            
            gameState.currentQuestion = {
                lensType,
                focalLength,
                objectDistance,
                objectHeight,
                lensX: canvas.width / 2,
                lensY: canvas.height / 2
            };
            
            drawScene();
        }

        function drawScene() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = window.innerWidth <= 768 ? 1.5 : 1;
            for (let x = 0; x <= canvas.width; x += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            const q = gameState.currentQuestion;
            
            // Draw principal axis
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 5]);
            ctx.beginPath();
            ctx.moveTo(0, q.lensY);
            ctx.lineTo(canvas.width, q.lensY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw lens
            const lensHeight = Math.min(canvas.height * 0.5, 150);
            
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(q.lensX, q.lensY - lensHeight);
            ctx.lineTo(q.lensX, q.lensY + lensHeight);
            ctx.stroke();
            
            const arrowSize = Math.max(20, GRID_SIZE * 1.2);
            ctx.fillStyle = '#000';
            
            if (q.lensType === 'convex') {
                drawLensArrowhead(ctx, q.lensX, q.lensY - lensHeight, 'up', arrowSize);
                drawLensArrowhead(ctx, q.lensX, q.lensY + lensHeight, 'down', arrowSize);
            } else {
                drawLensArrowhead(ctx, q.lensX, q.lensY - lensHeight, 'down', arrowSize);
                drawLensArrowhead(ctx, q.lensX, q.lensY + lensHeight, 'up', arrowSize);
            }
            
            // Draw focal points
            const focalPointLeft = q.lensX - q.focalLength;
            const focalPointRight = q.lensX + q.focalLength;
            const focalPointSize = Math.max(4, GRID_SIZE * 0.3);
            
            ctx.fillStyle = '#ff6b6b';
            ctx.beginPath();
            ctx.arc(focalPointLeft, q.lensY, focalPointSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(focalPointRight, q.lensY, focalPointSize, 0, Math.PI * 2);
            ctx.fill();
            
            const fontSize = Math.max(12, GRID_SIZE * 0.7);
            ctx.fillStyle = '#000';
            ctx.font = `bold ${fontSize}px sans-serif`;
            ctx.fillText('F', focalPointLeft - 5, q.lensY - 10);
            ctx.fillText('F', focalPointRight - 5, q.lensY - 10);
            
            // Draw object
            const objX = q.lensX - q.objectDistance;
            const objY = q.lensY;
            const objHeight = q.objectHeight;
            drawObjectImageArrow(ctx, objX, objY, objX, objY - objHeight, 10, '#2196f3', 3);
            
            ctx.fillStyle = '#2196f3';
            ctx.font = `bold ${fontSize}px sans-serif`;
            ctx.fillText('O', objX - 15, objY + 20);
            
            // Draw rays
            gameState.rays.forEach((ray, index) => {
                drawRay(ray, index);
            });
            
            // Draw image points
            if (gameState.mode === 'placingImage' && gameState.imagePoints.length > 0) {
                gameState.imagePoints.forEach(point => {
                    ctx.fillStyle = '#9b59b6';
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                if (gameState.imagePoints.length === 2) {
                    const q = gameState.currentQuestion;
                    let basePoint, topPoint;
                    
                    if (Math.abs(gameState.imagePoints[0].y - q.lensY) < Math.abs(gameState.imagePoints[1].y - q.lensY)) {
                        basePoint = gameState.imagePoints[0];
                        topPoint = gameState.imagePoints[1];
                    } else {
                        basePoint = gameState.imagePoints[1];
                        topPoint = gameState.imagePoints[0];
                    }
                    
                    drawObjectImageArrow(ctx, basePoint.x, basePoint.y, topPoint.x, topPoint.y, 10, '#9b59b6', 3);
                }
            }
        }

        function drawRay(ray, index) {
            const q = gameState.currentQuestion;
            const colors = ['#e74c3c', '#2ecc71', '#f39c12'];
            const color = colors[index % 3];
            
            // Analyze what type of ray this is
            const rayType = analyzeRayType(ray, q);
            
            // Draw based on ray type
            if (rayType.constructionLine) {
                // Draw construction line (dotted)
                ctx.strokeStyle = color;
                ctx.lineWidth = 2.5;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(rayType.constructionLine.x1, rayType.constructionLine.y1);
                ctx.lineTo(rayType.constructionLine.x2, rayType.constructionLine.y2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            if (rayType.mainRay) {
                // Draw main ray (solid with arrow)
                drawRayArrow(ctx, rayType.mainRay.x1, rayType.mainRay.y1, 
                           rayType.mainRay.x2, rayType.mainRay.y2, 8, color, 2.5);
            }
            
            if (rayType.virtualExtension) {
                // Draw virtual extension (dotted)
                ctx.strokeStyle = color;
                ctx.lineWidth = 2.5;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(rayType.virtualExtension.x1, rayType.virtualExtension.y1);
                ctx.lineTo(rayType.virtualExtension.x2, rayType.virtualExtension.y2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            if (rayType.realExtension) {
                // Draw real extension (solid)
                ctx.strokeStyle = color;
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                ctx.moveTo(rayType.realExtension.x1, rayType.realExtension.y1);
                ctx.lineTo(rayType.realExtension.x2, rayType.realExtension.y2);
                ctx.stroke();
            }
        }

        function analyzeRayType(ray, q) {
            const result = {
                mainRay: null,
                constructionLine: null,
                virtualExtension: null,
                realExtension: null
            };
            
            // Tight tolerance for exact point matching
            const pointTolerance = GRID_SIZE * 0.8;
            
            const objX = q.lensX - q.objectDistance;
            const objTopY = q.lensY - q.objectHeight;
            const nearF = { x: q.lensX - q.focalLength, y: q.lensY };
            const farF = { x: q.lensX + q.focalLength, y: q.lensY };
            
            const isVirtualImage = q.lensType === 'convex' && q.objectDistance < q.focalLength;
            const isConcave = q.lensType === 'concave';
            
            // Check click positions with tight tolerance
            const click1AtLens = Math.abs(ray.x1 - q.lensX) < pointTolerance;
            const click2AtLens = Math.abs(ray.x2 - q.lensX) < pointTolerance;
            const click1AtObjTop = Math.abs(ray.x1 - objX) < pointTolerance && Math.abs(ray.y1 - objTopY) < pointTolerance;
            const click2AtObjTop = Math.abs(ray.x2 - objX) < pointTolerance && Math.abs(ray.y2 - objTopY) < pointTolerance;
            const click1AtNearF = Math.abs(ray.x1 - nearF.x) < pointTolerance && Math.abs(ray.y1 - nearF.y) < pointTolerance;
            const click2AtNearF = Math.abs(ray.x2 - nearF.x) < pointTolerance && Math.abs(ray.y2 - nearF.y) < pointTolerance;
            const click1AtFarF = Math.abs(ray.x1 - farF.x) < pointTolerance && Math.abs(ray.y1 - farF.y) < pointTolerance;
            const click2AtFarF = Math.abs(ray.x2 - farF.x) < pointTolerance && Math.abs(ray.y2 - farF.y) < pointTolerance;
            const click1AtCenter = click1AtLens && Math.abs(ray.y1 - q.lensY) < pointTolerance;
            const click2AtCenter = click2AtLens && Math.abs(ray.y2 - q.lensY) < pointTolerance;
            
            // Check for special ray4 snapping points
            const ray4Point = findRay4EndPoint(q);
            const click1AtRay4 = ray4Point && Math.abs(ray.x1 - ray4Point.x) < pointTolerance && Math.abs(ray.y1 - ray4Point.y) < pointTolerance;
            
            const ray13Point = findRay13EndPoint(q);
            const click1AtRay13 = ray13Point && Math.abs(ray.x1 - ray13Point.x) < pointTolerance && Math.abs(ray.y1 - ray13Point.y) < pointTolerance;
            
            // CONVEX LENS - REAL IMAGE
            if (q.lensType === 'convex' && q.objectDistance > q.focalLength) {
                // Rule 2: Lens â†’ Far F
                if (click1AtLens && click2AtFarF) {
                    result.mainRay = { x1: ray.x1, y1: ray.y1, x2: ray.x2, y2: ray.y2 };
                    // Extrapolate in same direction
                    const dx = ray.x2 - ray.x1;
                    const dy = ray.y2 - ray.y1;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const dirX = dx / length;
                    const dirY = dy / length;
                    const extendDist = 500;
                    result.realExtension = { 
                        x1: ray.x2, y1: ray.y2, 
                        x2: ray.x2 + dirX * extendDist, y2: ray.y2 + dirY * extendDist 
                    };
                }
                // Rule 3: Object top â†’ Center
                else if (click1AtObjTop && click2AtCenter) {
                    result.mainRay = { x1: ray.x1, y1: ray.y1, x2: ray.x2, y2: ray.y2 };
                    // Extrapolate in same direction
                    const dx = ray.x2 - ray.x1;
                    const dy = ray.y2 - ray.y1;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const dirX = dx / length;
                    const dirY = dy / length;
                    const extendDist = 500;
                    result.realExtension = { 
                        x1: ray.x2, y1: ray.y2, 
                        x2: ray.x2 + dirX * extendDist, y2: ray.y2 + dirY * extendDist 
                    };
                }
                // Rule 4: Object top â†’ Near F
                else if (click1AtObjTop && click2AtNearF) {
                    // Calculate intersection with lens
                    const dx = ray.x2 - ray.x1;
                    const dy = ray.y2 - ray.y1;
                    const t = (q.lensX - ray.x1) / dx;
                    const yAtLens = ray.y1 + t * dy;
                    
                    result.mainRay = { x1: ray.x1, y1: ray.y1, x2: q.lensX, y2: yAtLens };
                }
                // Rule 5: Lens (ray4 end) â†’ parallel
                else if (click1AtRay4 && isParallelish(ray, q.lensY)) {
                    result.mainRay = { x1: ray.x1, y1: ray.y1, x2: canvas.width, y2: ray.y1 };
                }
                // Default
                else {
                    result.mainRay = { x1: ray.x1, y1: ray.y1, x2: ray.x2, y2: ray.y2 };
                }
            }
            // CONVEX LENS - VIRTUAL IMAGE
            else if (q.lensType === 'convex' && q.objectDistance < q.focalLength) {
                // Rule 6: Lens â†’ Far F
                if (click1AtLens && click2AtFarF) {
                    result.mainRay = { x1: ray.x1, y1: ray.y1, x2: ray.x2, y2: ray.y2 };
                    // Extrapolate in same direction (forward and backward)
                    const dx = ray.x2 - ray.x1;
                    const dy = ray.y2 - ray.y1;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const dirX = dx / length;
                    const dirY = dy / length;
                    const extendDist = 500;
                    result.realExtension = { 
                        x1: ray.x2, y1: ray.y2, 
                        x2: ray.x2 + dirX * extendDist, y2: ray.y2 + dirY * extendDist 
                    };
                    result.virtualExtension = { 
                        x1: ray.x1, y1: ray.y1, 
                        x2: ray.x1 - dirX * extendDist, y2: ray.y1 - dirY * extendDist 
                    };
                }
                // Rule 7: Object top â†’ Center
                else if (click1AtObjTop && click2AtCenter) {
                    result.mainRay = { x1: ray.x1, y1: ray.y1, x2: ray.x2, y2: ray.y2 };
                    // Extrapolate in same direction (forward and backward)
                    const dx = ray.x2 - ray.x1;
                    const dy = ray.y2 - ray.y1;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const dirX = dx / length;
                    const dirY = dy / length;
                    const extendDist = 500;
                    result.realExtension = { 
                        x1: ray.x2, y1: ray.y2, 
                        x2: ray.x2 + dirX * extendDist, y2: ray.y2 + dirY * extendDist 
                    };
                    result.virtualExtension = { 
                        x1: ray.x1, y1: ray.y1, 
                        x2: ray.x1 - dirX * extendDist, y2: ray.y1 - dirY * extendDist 
                    };
                }
                // Rule 8: Near F â†’ Object top
                else if (click1AtNearF && click2AtObjTop) {
                    result.constructionLine = { x1: ray.x1, y1: ray.y1, x2: ray.x2, y2: ray.y2 };
                    
                    // Calculate ray from object to lens
                    const dx = objX - nearF.x;
                    const dy = objTopY - nearF.y;
                    const t = (q.lensX - objX) / dx;
                    const yAtLens = objTopY + t * dy;
                    
                    result.mainRay = { x1: objX, y1: objTopY, x2: q.lensX, y2: yAtLens };
                }
                // Rule 9: Lens (ray8 end) â†’ parallel
                else if (click1AtRay4 && isParallelish(ray, q.lensY)) {
                    result.mainRay = { x1: ray.x1, y1: ray.y1, x2: canvas.width, y2: ray.y1 };
                    result.virtualExtension = { x1: ray.x1, y1: ray.y1, x2: 0, y2: ray.y1 };
                }
                // Default
                else {
                    result.mainRay = { x1: ray.x1, y1: ray.y1, x2: ray.x2, y2: ray.y2 };
                }
            }
            // CONCAVE LENS
            else if (q.lensType === 'concave') {
                // Rule 10: Object top â†’ Lens (parallel)
                if (click1AtObjTop && click2AtLens && Math.abs(ray.y2 - ray.y1) < pointTolerance) {
                    result.mainRay = { x1: ray.x1, y1: ray.y1, x2: ray.x2, y2: ray.y2 };
                }
                // Rule 11: Near F â†’ Lens (parallel to object top)
                else if (click1AtNearF && click2AtLens) {
                    // Dotted construction line from near F to lens
                    result.constructionLine = { x1: ray.x1, y1: ray.y1, x2: ray.x2, y2: ray.y2 };
                    // Real ray extends from lens in same direction
                    const dx = ray.x2 - ray.x1;
                    const dy = ray.y2 - ray.y1;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const dirX = dx / length;
                    const dirY = dy / length;
                    const extendDist = 500;
                    result.realExtension = { 
                        x1: ray.x2, y1: ray.y2, 
                        x2: ray.x2 + dirX * extendDist, y2: ray.y2 + dirY * extendDist 
                    };
                }
                // Rule 12: Object top â†’ Center
                else if (click1AtObjTop && click2AtCenter) {
                    result.mainRay = { x1: ray.x1, y1: ray.y1, x2: ray.x2, y2: ray.y2 };
                    // Extrapolate in same direction (forward and backward)
                    const dx = ray.x2 - ray.x1;
                    const dy = ray.y2 - ray.y1;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const dirX = dx / length;
                    const dirY = dy / length;
                    const extendDist = 500;
                    result.realExtension = { 
                        x1: ray.x2, y1: ray.y2, 
                        x2: ray.x2 + dirX * extendDist, y2: ray.y2 + dirY * extendDist 
                    };
                    result.virtualExtension = { 
                        x1: ray.x1, y1: ray.y1, 
                        x2: ray.x1 - dirX * extendDist, y2: ray.y1 - dirY * extendDist 
                    };
                }
                // Rule 13: Object top â†’ Far F
                else if (click1AtObjTop && click2AtFarF) {
                    // Calculate where ray hits lens
                    const dx = ray.x2 - ray.x1;
                    const dy = ray.y2 - ray.y1;
                    const t = (q.lensX - ray.x1) / dx;
                    const yAtLens = ray.y1 + t * dy;
                    
                    // Real ray from object to lens
                    result.mainRay = { x1: ray.x1, y1: ray.y1, x2: q.lensX, y2: yAtLens };
                    // Construction line from lens to far F
                    result.constructionLine = { x1: q.lensX, y1: yAtLens, x2: farF.x, y2: farF.y };
                    // No extrapolation beyond far F
                }
                // Rule 14: Lens (ray13 end) â†’ parallel right
                else if (click1AtRay13 && isParallelish(ray, q.lensY) && ray.x2 > ray.x1) {
                    result.mainRay = { x1: ray.x1, y1: ray.y1, x2: canvas.width, y2: ray.y1 };
                    result.virtualExtension = { x1: ray.x1, y1: ray.y1, x2: 0, y2: ray.y1 };
                }
                // Default
                else {
                    result.mainRay = { x1: ray.x1, y1: ray.y1, x2: ray.x2, y2: ray.y2 };
                }
            }
            
            return result;
        }

        function isParallelish(ray, axisY) {
            // Check if the ray is horizontal (Y values are similar)
            // More lenient tolerance for detecting horizontal/parallel rays
            const parallelTolerance = GRID_SIZE * 1.5;
            return Math.abs(ray.y2 - ray.y1) < parallelTolerance;
        }

        function findRay4EndPoint(q) {
            // Find where ray from object top to near F hits lens
            const objX = q.lensX - q.objectDistance;
            const objTopY = q.lensY - q.objectHeight;
            const nearF = { x: q.lensX - q.focalLength, y: q.lensY };
            
            for (const ray of gameState.rays) {
                const pointTolerance = GRID_SIZE * 0.8;
                const click1AtObjTop = Math.abs(ray.x1 - objX) < pointTolerance && Math.abs(ray.y1 - objTopY) < pointTolerance;
                const click2AtNearF = Math.abs(ray.x2 - nearF.x) < pointTolerance && Math.abs(ray.y2 - nearF.y) < pointTolerance;
                
                if (click1AtObjTop && click2AtNearF) {
                    const dx = ray.x2 - ray.x1;
                    const dy = ray.y2 - ray.y1;
                    const t = (q.lensX - ray.x1) / dx;
                    const yAtLens = ray.y1 + t * dy;
                    return { x: q.lensX, y: yAtLens };
                }
            }
            
            return null;
        }

        function findRay13EndPoint(q) {
            // Find where ray from object top to far F hits lens (concave)
            const objX = q.lensX - q.objectDistance;
            const objTopY = q.lensY - q.objectHeight;
            const farF = { x: q.lensX + q.focalLength, y: q.lensY };
            
            for (const ray of gameState.rays) {
                const pointTolerance = GRID_SIZE * 0.8;
                const click1AtObjTop = Math.abs(ray.x1 - objX) < pointTolerance && Math.abs(ray.y1 - objTopY) < pointTolerance;
                const click2AtFarF = Math.abs(ray.x2 - farF.x) < pointTolerance && Math.abs(ray.y2 - farF.y) < pointTolerance;
                
                if (click1AtObjTop && click2AtFarF) {
                    const dx = ray.x2 - ray.x1;
                    const dy = ray.y2 - ray.y1;
                    const t = (q.lensX - ray.x1) / dx;
                    const yAtLens = ray.y1 + t * dy;
                    return { x: q.lensX, y: yAtLens };
                }
            }
            
            return null;
        }

        function drawLensArrowhead(ctx, x, y, direction, size) {
            ctx.fillStyle = '#000';
            ctx.beginPath();
            
            if (direction === 'up') {
                ctx.moveTo(x, y - size);
                ctx.lineTo(x - size/2, y);
                ctx.lineTo(x + size/2, y);
            } else if (direction === 'down') {
                ctx.moveTo(x, y + size);
                ctx.lineTo(x - size/2, y);
                ctx.lineTo(x + size/2, y);
            }
            
            ctx.closePath();
            ctx.fill();
        }

        function drawObjectImageArrow(ctx, x1, y1, x2, y2, arrowSize, color, lineWidth = 2) {
            const responsiveArrowSize = Math.max(arrowSize, GRID_SIZE * 0.5);
            
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = lineWidth;
            
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            
            const angle = Math.atan2(y2 - y1, x2 - x1);
            
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - responsiveArrowSize * Math.cos(angle - Math.PI / 6), 
                       y2 - responsiveArrowSize * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(x2 - responsiveArrowSize * Math.cos(angle + Math.PI / 6), 
                       y2 - responsiveArrowSize * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
        }

        function drawRayArrow(ctx, x1, y1, x2, y2, arrowSize, color, lineWidth = 2) {
            const responsiveArrowSize = Math.max(arrowSize, GRID_SIZE * 0.4);
            
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = lineWidth;
            
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            
            const midX = (x1 + x2) / 2;
            const midY = (y1 + y2) / 2;
            const angle = Math.atan2(y2 - y1, x2 - x1);
            
            ctx.beginPath();
            ctx.moveTo(midX, midY);
            ctx.lineTo(midX - responsiveArrowSize * Math.cos(angle - Math.PI / 6), 
                       midY - responsiveArrowSize * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(midX - responsiveArrowSize * Math.cos(angle + Math.PI / 6), 
                       midY - responsiveArrowSize * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
        }

        function snapToGrid(x, y) {
            return {
                x: Math.round(x / GRID_SIZE) * GRID_SIZE,
                y: Math.round(y / GRID_SIZE) * GRID_SIZE
            };
        }

        function handleCanvasInteraction(e) {
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            let x, y;
            
            if (e.type.startsWith('touch')) {
                const touch = e.touches[0] || e.changedTouches[0];
                x = touch.clientX - rect.left;
                y = touch.clientY - rect.top;
            } else {
                x = e.clientX - rect.left;
                y = e.clientY - rect.top;
            }
            
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            x *= scaleX;
            y *= scaleY;
            
            const q = gameState.currentQuestion;
            const objX = q.lensX - q.objectDistance;
            const objTopY = q.lensY - q.objectHeight;
            
            // Start with grid snapping
            let snapped = { x: Math.round(x / GRID_SIZE) * GRID_SIZE, y: Math.round(y / GRID_SIZE) * GRID_SIZE };
            
            // Special points - ORDER MATTERS! Ray end points FIRST (highest priority)
            const snapTolerance = GRID_SIZE * 1.2;
            const specialPoints = [];
            
            // PRIORITY 1: Ray end points (these must snap first!)
            const ray4Point = findRay4EndPoint(q);
            if (ray4Point) specialPoints.push(ray4Point);
            
            const ray13Point = findRay13EndPoint(q);
            if (ray13Point) specialPoints.push(ray13Point);
            
            // PRIORITY 2: Other important points
            specialPoints.push(
                { x: q.lensX, y: q.lensY },                      // Lens center
                { x: q.lensX - q.focalLength, y: q.lensY },      // Near focal point
                { x: q.lensX + q.focalLength, y: q.lensY },      // Far focal point
                { x: objX, y: objTopY },                         // Object top
                { x: objX, y: q.lensY }                          // Object base
            );
            
            // Check if click is near any special point (first match wins)
            for (let point of specialPoints) {
                const dist = Math.sqrt((x - point.x) ** 2 + (y - point.y) ** 2);
                if (dist < snapTolerance) {
                    snapped = { x: point.x, y: point.y };
                    break;
                }
            }
            
            // Also check for clicking on lens line (not just center)
            if (Math.abs(x - q.lensX) < GRID_SIZE * 1.2) {
                snapped.x = q.lensX;
            }
            
            if (gameState.mode === 'drawingRays') {
                if (clickCount === 0) {
                    firstClick = snapped;
                    clickCount = 1;
                    
                    ctx.fillStyle = 'rgba(102, 126, 234, 0.5)';
                    ctx.beginPath();
                    ctx.arc(snapped.x, snapped.y, 10, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Second click - check if it should snap to parallel for rules 5, 9, 14
                    const parallelTolerance = GRID_SIZE * 1.5;
                    
                    const isFromRay4 = ray4Point && 
                                      Math.abs(firstClick.x - ray4Point.x) < GRID_SIZE * 0.5 && 
                                      Math.abs(firstClick.y - ray4Point.y) < GRID_SIZE * 0.5;
                    const isFromRay13 = ray13Point && 
                                       Math.abs(firstClick.x - ray13Point.x) < GRID_SIZE * 0.5 && 
                                       Math.abs(firstClick.y - ray13Point.y) < GRID_SIZE * 0.5;
                    
                    // If starting from ray4/ray13 end and clicking roughly parallel, snap to parallel
                    if ((isFromRay4 || isFromRay13) && Math.abs(y - firstClick.y) < parallelTolerance) {
                        snapped.y = firstClick.y; // Force parallel
                    }
                    
                    gameState.rays.push({
                        x1: firstClick.x,
                        y1: firstClick.y,
                        x2: snapped.x,
                        y2: snapped.y
                    });
                    clickCount = 0;
                    firstClick = null;
                    
                    // Allow placing image after 1+ rays
                    if (gameState.rays.length >= 1) {
                        document.getElementById('placeImageBtn').style.display = 'inline-block';
                        if (gameState.rays.length >= 2) {
                            document.getElementById('modeIndicator').textContent = 'Ready! Click "Place Image"';
                        } else {
                            document.getElementById('modeIndicator').textContent = 'Draw more rays or Place Image';
                        }
                    }
                    
                    drawScene();
                }
            } else if (gameState.mode === 'placingImage') {
                // Calculate where the image SHOULD be
                const correctImage = calculateImagePosition();
                
                if (correctImage) {
                    let expectedImageX;
                    if (correctImage.side === 'right') {
                        expectedImageX = q.lensX + correctImage.distance;
                    } else {
                        expectedImageX = q.lensX - correctImage.distance;
                    }
                    
                    const expectedImageBaseY = q.lensY;
                    let expectedImageTopY = correctImage.isInverted ? 
                        q.lensY + correctImage.height : 
                        q.lensY - correctImage.height;
                    
                    // If clicking near the correct position, snap to it
                    const imageSnapTolerance = GRID_SIZE * 2.5; // More lenient for image placement
                    
                    // Check if clicking near correct base position
                    const distToBase = Math.sqrt((x - expectedImageX) ** 2 + (y - expectedImageBaseY) ** 2);
                    if (distToBase < imageSnapTolerance) {
                        snapped = { x: expectedImageX, y: expectedImageBaseY };
                    }
                    
                    // Check if clicking near correct top position  
                    const distToTop = Math.sqrt((x - expectedImageX) ** 2 + (y - expectedImageTopY) ** 2);
                    if (distToTop < imageSnapTolerance) {
                        snapped = { x: expectedImageX, y: expectedImageTopY };
                    }
                }
                
                gameState.imagePoints.push(snapped);
                
                if (gameState.imagePoints.length === 2) {
                    checkAnswer();
                }
                
                drawScene();
            }
        }

        function undoLastRay() {
            // If we're in the middle of drawing a ray (first click made), just cancel it
            if (clickCount === 1) {
                clickCount = 0;
                firstClick = null;
                drawScene();
                return;
            }
            
            // Otherwise, remove the last completed ray
            if (gameState.rays.length > 0) {
                gameState.rays.pop();
                
                if (gameState.rays.length === 0) {
                    document.getElementById('placeImageBtn').style.display = 'none';
                    document.getElementById('modeIndicator').textContent = 'Drawing Rays (Draw at least 2)';
                } else if (gameState.rays.length === 1) {
                    document.getElementById('modeIndicator').textContent = 'Draw more rays or Place Image';
                } else {
                    document.getElementById('modeIndicator').textContent = 'Ready! Click "Place Image"';
                }
                
                drawScene();
            }
        }

        function startPlacingImage() {
            gameState.mode = 'placingImage';
            gameState.imagePoints = [];
            document.getElementById('modeIndicator').textContent = 'Placing Image (click base, then top)';
            document.getElementById('placeImageBtn').style.display = 'none';
            document.getElementById('cancelImageBtn').style.display = 'inline-block';
        }
        
        function cancelPlacingImage() {
            gameState.mode = 'drawingRays';
            gameState.imagePoints = [];
            
            if (gameState.rays.length >= 2) {
                document.getElementById('modeIndicator').textContent = 'Ready! Click "Place Image"';
            } else if (gameState.rays.length === 1) {
                document.getElementById('modeIndicator').textContent = 'Draw more rays or Place Image';
            } else {
                document.getElementById('modeIndicator').textContent = 'Drawing Rays (Draw at least 2)';
            }
            
            document.getElementById('cancelImageBtn').style.display = 'none';
            if (gameState.rays.length >= 1) {
                document.getElementById('placeImageBtn').style.display = 'inline-block';
            }
            drawScene();
        }

        function calculateImagePosition() {
            const q = gameState.currentQuestion;
            const u = q.objectDistance;
            const f = q.focalLength;
            
            let v, m, imageHeight;
            
            if (q.lensType === 'convex') {
                if (Math.abs(u - f) < 5) {
                    return null;
                }
                
                v = (f * u) / (u - f);
                m = v / u;
                imageHeight = m * q.objectHeight;
                
                return {
                    distance: Math.abs(v),
                    height: Math.abs(imageHeight),
                    isReal: v > 0,
                    isInverted: v > 0,
                    side: v > 0 ? 'right' : 'left'
                };
            } else {
                v = (f * u) / (u + f);
                m = v / u;
                imageHeight = m * q.objectHeight;
                
                return {
                    distance: Math.abs(v),
                    height: Math.abs(imageHeight),
                    isReal: false,
                    isInverted: false,
                    side: 'left'
                };
            }
        }

        function checkAnswer() {
            const q = gameState.currentQuestion;
            const correctImage = calculateImagePosition();
            
            if (!correctImage) {
                showFeedback(false, "No real image is formed when object is at the focal point!");
                return;
            }
            
            let expectedImageX;
            if (correctImage.side === 'right') {
                expectedImageX = q.lensX + correctImage.distance;
            } else {
                expectedImageX = q.lensX - correctImage.distance;
            }
            
            // Don't grid-snap - use exact positions since we snap during placement
            const expectedImageY1 = q.lensY;
            let expectedImageY2 = correctImage.isInverted ? 
                q.lensY + correctImage.height : 
                q.lensY - correctImage.height;
            
            const userPoints = gameState.imagePoints;
            let basePoint, topPoint;
            
            if (Math.abs(userPoints[0].y - q.lensY) < Math.abs(userPoints[1].y - q.lensY)) {
                basePoint = userPoints[0];
                topPoint = userPoints[1];
            } else {
                basePoint = userPoints[1];
                topPoint = userPoints[0];
            }
            
            const tolerance = GRID_SIZE; // One grid square tolerance
            const xCorrect = Math.abs(basePoint.x - expectedImageX) < tolerance;
            const baseYCorrect = Math.abs(basePoint.y - expectedImageY1) < tolerance;
            const topYCorrect = Math.abs(topPoint.y - expectedImageY2) < tolerance;
            const topXCorrect = Math.abs(topPoint.x - expectedImageX) < tolerance;
            
            const imageCorrect = xCorrect && baseYCorrect && topYCorrect && topXCorrect;
            
            // Check rays - validate for feedback, but don't require them all to be correct
            const rayErrors = validateRays(q);
            const allRaysCorrect = rayErrors.length === 0;
            
            if (imageCorrect) {
                // Image is correct - this is the main criterion
                const basePoints = 100;
                let accuracyBonus = 0;
                let rayBonus = 0;
                
                // Accuracy bonus based on attempts
                if (gameState.attemptsRemaining === 3) accuracyBonus = 50;
                else if (gameState.attemptsRemaining === 2) accuracyBonus = 25;
                
                // Ray bonus - full bonus only if all rays correct
                if (allRaysCorrect) {
                    rayBonus = 50;
                } else if (rayErrors.length <= 1) {
                    rayBonus = 25; // Small error
                }
                // No ray bonus if 2+ errors
                
                const totalPoints = basePoints + accuracyBonus + rayBonus;
                
                gameState.score += totalPoints;
                gameState.correctCount++;
                
                document.getElementById('score').textContent = gameState.score;
                document.getElementById('correct').textContent = gameState.correctCount;
                
                let message = `Correct image! +${totalPoints} points!`;
                if (!allRaysCorrect) {
                    message = `Image correct! +${totalPoints} points. However, some rays need work:`;
                }
                
                showFeedback(true, message, allRaysCorrect ? [] : rayErrors);
                setTimeout(() => {
                    generateQuestion();
                }, allRaysCorrect ? 2500 : 4000);
            } else {
                // Image is incorrect
                gameState.attemptsRemaining--;
                
                let errorMsg = 'Image position incorrect. ';
                gameState.mistakes.push('Image position incorrect');
                
                if (!allRaysCorrect) {
                    rayErrors.forEach(err => gameState.mistakes.push(err));
                }
                
                if (gameState.attemptsRemaining > 0) {
                    errorMsg += `${gameState.attemptsRemaining} attempts remaining.`;
                    showFeedback(false, errorMsg, rayErrors);
                    
                    setTimeout(() => {
                        gameState.mode = 'drawingRays';
                        gameState.imagePoints = [];
                        document.getElementById('modeIndicator').textContent = 'Drawing Rays - Try Again';
                        document.getElementById('attemptsIndicator').style.display = 'inline-block';
                        document.getElementById('attemptsIndicator').textContent = `Attempts: ${gameState.attemptsRemaining}`;
                        document.getElementById('cancelImageBtn').style.display = 'none';
                        drawScene();
                    }, 4000);
                } else {
                    showFeedback(false, "Out of attempts. Moving to next question.", rayErrors);
                    setTimeout(() => {
                        generateQuestion();
                    }, 4000);
                }
            }
        }

        function validateRays(q) {
            const errors = [];
            const pointTolerance = GRID_SIZE * 0.8;
            
            const objX = q.lensX - q.objectDistance;
            const objTopY = q.lensY - q.objectHeight;
            const nearF = { x: q.lensX - q.focalLength, y: q.lensY };
            const farF = { x: q.lensX + q.focalLength, y: q.lensY };
            
            const isVirtualImage = q.lensType === 'convex' && q.objectDistance < q.focalLength;
            
            // Only check if rays are present (don't complain about missing ones)
            if (gameState.rays.length === 0) {
                errors.push('No rays drawn - you should draw at least 2 rays to locate the image');
                return errors;
            }
            
            if (gameState.rays.length === 1) {
                errors.push('Only 1 ray drawn - you need at least 2 rays to accurately locate the image');
                return errors;
            }
            
            // Check which rays are present and if they're drawn incorrectly
            // We DON'T complain about missing rays, only incorrect ones
            
            return errors; // For now, just ensure at least 2 rays exist
        }

        function showFeedback(isCorrect, message, rayErrors = []) {
            const feedback = document.getElementById('feedback');
            const title = document.getElementById('feedbackTitle');
            const text = document.getElementById('feedbackText');
            const rayErrorsList = document.getElementById('feedbackRayErrors');
            
            feedback.className = 'feedback show ' + (isCorrect ? 'correct' : 'incorrect');
            title.textContent = isCorrect ? 'âœ“ Correct!' : 'âœ— Incorrect';
            text.textContent = message;
            
            if (rayErrors && rayErrors.length > 0) {
                rayErrorsList.style.display = 'block';
                rayErrorsList.innerHTML = '';
                rayErrors.forEach(error => {
                    const li = document.createElement('li');
                    li.textContent = error;
                    rayErrorsList.appendChild(li);
                });
            } else {
                rayErrorsList.style.display = 'none';
            }
            
            setTimeout(() => {
                feedback.classList.remove('show');
            }, isCorrect ? 2500 : 4000);
        }

        function skipQuestion() {
            gameState.mistakes.push('Question skipped');
            generateQuestion();
        }

        function endGame() {
            clearInterval(gameState.timerInterval);
            
            document.querySelector('.game-screen').classList.remove('active');
            document.querySelector('.results-screen').classList.add('active');
            
            const accuracy = gameState.attemptedCount > 0 ? 
                Math.round((gameState.correctCount / gameState.attemptedCount) * 100) : 0;
            
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('finalAttempted').textContent = gameState.attemptedCount;
            document.getElementById('finalCorrect').textContent = gameState.correctCount;
            document.getElementById('finalAccuracy').textContent = accuracy + '%';
            
            const mistakesUl = document.getElementById('mistakesUl');
            if (gameState.mistakes.length > 0) {
                const mistakeCounts = {};
                gameState.mistakes.forEach(m => {
                    mistakeCounts[m] = (mistakeCounts[m] || 0) + 1;
                });
                
                mistakesUl.innerHTML = '';
                Object.entries(mistakeCounts).forEach(([mistake, count]) => {
                    const li = document.createElement('li');
                    li.textContent = `${mistake} (${count} time${count > 1 ? 's' : ''})`;
                    mistakesUl.appendChild(li);
                });
            } else {
                mistakesUl.innerHTML = '<li>No mistakes recorded - perfect performance!</li>';
            }
        }
    </script>
</body>
</html>
